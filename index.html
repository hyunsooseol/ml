<!-- ✅ SNOWSOFT | 간편 머신러닝 분석 (업로더: 아이콘+문구+오른쪽 버튼 스타일, ROC-AUC+임곗값 슬라이더) -->
<style>
  @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@500;700;900&display=swap');
  .ml, .ml *{font-family:'Noto Sans KR','Apple SD Gothic Neo','Malgun Gothic',system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; box-sizing:border-box}
  .ml{--navy:#0f2e59; --cobalt:#174a8c; --text:#0F172A; --dim:#475569; --card:#fff; --br:#e6ecf4; --r-xl:20px}
  .ml .hero{max-width:1120px;margin:24px auto 32px;padding:52px 22px 46px;color:#fff;text-align:center;border-radius:var(--r-xl);
    background:radial-gradient(900px 380px at 10% -20%, rgba(23,74,140,.35), transparent 60%),
               radial-gradient(800px 420px at 100% 0%, rgba(0,178,255,.16), transparent 60%),
               linear-gradient(160deg, var(--navy) 0%, var(--cobalt) 100%)}
  .ml .hero h1{margin:0 0 8px;font-size:28px;font-weight:900}
  .ml .hero p{margin:0;font-size:15.5px;opacity:.95}

  .ml .card{background:var(--card);border:1px solid var(--br);border-radius:var(--r-xl);max-width:1160px;margin:0 auto 22px;padding:20px 22px;color:var(--text);
    box-shadow:0 10px 32px rgba(16,24,40,.08)}
  .ml .h2{margin:0 0 14px;font-size:20px;font-weight:800;color:var(--navy)}
  .ml .sub{color:var(--dim);font-size:14px}
  .ml label{display:block;font-size:13px;color:#2b3345;margin-bottom:6px}
  .ml select,.ml input[type=number],.ml input[type=range]{width:100%;padding:10px 12px;border:1px solid #e5e7eb;border-radius:10px;background:#fff;font-size:14px}
  .ml .chips{display:flex;flex-wrap:wrap;gap:8px}
  .ml .chip{padding:6px 10px;border-radius:999px;border:1px solid #e5e7eb;font-size:12px;cursor:pointer}
  .ml .chip.active{background:#eef2ff;border-color:#c7d2fe}
  .ml .btn{appearance:none;border:1px solid #e5e7eb;background:#fff;border-radius:12px;padding:10px 14px;font-weight:800;font-size:14px;cursor:pointer;transition:.18s; text-decoration:none}
  .ml .btn:hover{transform:translateY(-1px);box-shadow:0 6px 16px rgba(0,0,0,.08)}
  .ml .btn.primary{color:#fff;background:linear-gradient(90deg,#0f2e59,#174a8c);border:none}
  .ml .btn.ghost{background:#fff;border-color:#e2e8f0}
  .ml .btn.ghost:hover{box-shadow:0 6px 16px rgba(2,6,23,.06)}

  /* 업로더: 아이콘+문구(좌), 파일선택 버튼(우) */
  .ml .uploader{
    position:relative;border:1px dashed #cbd5e1;border-radius:14px;background:#fafcff;padding:14px 16px;
    display:flex;align-items:center;justify-content:space-between;gap:12px
  }
  .ml .uploader-left{display:flex;align-items:center;gap:10px}
  .ml .uploader-icon{
    width:22px;height:22px;border-radius:8px;display:inline-flex;align-items:center;justify-content:center;
    background:#eef6ff;border:1px solid #dbeafe
  }
  .ml .uploader strong{font-weight:800}
  .ml .uploader small{color:#64748b}

  /* 입력 패널 & 배지 */
  .ml .panel{border:1px solid var(--br);border-radius:14px;padding:14px}
  .ml .controls{display:grid;grid-template-columns:1fr;gap:16px}
  .ml .badges{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0 0}
  .ml .badge{font-size:12px;border:1px solid #e5e7eb;border-radius:999px;padding:6px 10px;background:#f8fafc}

  /* 결과 레이아웃: 하단 가로 배치 */
  .ml .results{margin-top:18px}
  .ml .results-grid{display:grid;grid-template-columns:1.2fr 1fr 1fr;gap:16px}
  @media (max-width:1100px){ .ml .results-grid{grid-template-columns:1fr 1fr} }
  @media (max-width:760px){ .ml .results-grid{grid-template-columns:1fr} }

  .ml .table-wrap{border:1px solid #e9eef5;border-radius:14px;overflow:auto;max-height:340px}
  .ml table{width:100%;border-collapse:separate;border-spacing:0;font-size:14px}
  .ml thead th{position:sticky;top:0;background:#f8fafc;color:#2b3345;font-weight:800;text-align:left;padding:10px;border-bottom:1px solid #e9eef5}
  .ml tbody td{padding:10px;border-top:1px solid #eef2f7}

  /* Confusion Matrix */
  .ml .cm{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
  .ml .cm > div{border:1px solid #e5e7eb;border-radius:12px;padding:12px;text-align:center}
  .ml .cm .sub{font-size:11px;color:#64748b}

  .ml .log{margin-top:10px;border:1px dashed #cbd5e1;border-radius:12px;background:#fbfdff;padding:10px;font-size:12px;color:#0b1220;white-space:pre-wrap}
  .ml .cta-center{display:flex;justify-content:center;align-items:center;margin:16px 0 0}
</style>

<section class="ml" id="ml-app">
  <div class="hero">
    <h1>간편 머신러닝 분석</h1>
    <p>로컬 CSV를 업로드하고, 변수만 선택하면 즉시 분류/회귀 결과를 확인합니다.</p>
  </div>

  <!-- 입력/설정 카드 -->
  <div class="card">
    <div class="h2">분석 시작</div>
    <p class="sub">CSV를 선택하면 아래 설정이 활성화됩니다. (데이터는 브라우저에서만 처리)</p>

    <!-- 업로더 (좌: 아이콘+문구, 우: 파일 선택 버튼) -->
    <div class="uploader" id="ml-drop">
      <div class="uploader-left">
        <span class="uploader-icon" aria-hidden="true">
          <!-- 업로드 아이콘 (SVG) -->
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path d="M12 16V4m0 0l-4 4m4-4l4 4" stroke="#0f2e59" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M20 16v3a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1v-3" stroke="#0f2e59" stroke-width="2" stroke-linecap="round"/>
          </svg>
        </span>
        <div>
          <strong id="ml-file-name">CSV 파일을 선택하거나 드롭하세요</strong><br>
          <small id="ml-file-hint"></small>
        </div>
      </div>
      <button type="button" class="btn ghost" id="ml-choose">파일 선택</button>
      <!-- 네이티브 파일 입력: 숨김 -->
      <input id="ml-file" type="file" accept=".csv,text/csv" style="display:none" />
    </div>

    <div class="log" id="ml-log">상태: 대기</div>

    <div class="controls">
      <div class="panel">
        <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:12px">
          <div>
            <label>Task</label>
            <select id="ml-task">
              <option value="auto">Auto</option>
              <option value="bincls">Binary Classification</option>
              <option value="reg">Regression</option>
            </select>
          </div>
          <div><label>Epochs</label><input id="ml-epochs" type="number" value="30" min="1"></div>
          <div><label>Batch Size</label><input id="ml-batch" type="number" value="32" min="1"></div>
        </div>

        <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px">
          <div>
            <label>Train/Test Split</label>
            <input id="ml-split" type="range" min="50" max="90" value="80">
            <div style="display:flex;justify-content:space-between;font-size:12px;color:#64748b">
              <span>Train</span><span id="ml-split-label">80%</span><span>Test</span>
            </div>
          </div>
          <div><label>Target</label><select id="ml-target"></select></div>
        </div>

        <div style="margin-top:12px">
          <label>Features (if empty = all except target)</label>
          <div id="ml-preds" class="chips"></div>
        </div>

        <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:14px">
          <button id="ml-train" class="btn primary" disabled>학습 시작</button>
          <button id="ml-clear" class="btn" disabled>초기화</button>
        </div>
        <div id="ml-progress" class="sub" style="margin-top:8px;display:none">학습 중… <span id="ml-ptext"></span></div>

        <!-- 배지: 행/열/테스트 N -->
        <div class="badges">
          <span class="badge">행 <b id="ml-nrow">-</b></span>
          <span class="badge">열 <b id="ml-ncol">-</b></span>
          <span class="badge">테스트 샘플 <b id="ml-ntest">-</b></span>
        </div>
      </div>
    </div>
  </div>

  <!-- 결과 카드 (하단 가로 배치) -->
  <div class="card results">
    <div class="h2">결과</div>

    <!-- 임곗값 슬라이더(분류일 때만 노출) -->
    <div id="ml-thres-wrap" class="panel" style="display:none;margin-bottom:12px">
      <div style="display:flex;gap:18px;align-items:center;flex-wrap:wrap">
        <div style="min-width:220px">
          <label>Decision Threshold</label>
          <input id="ml-thres" type="range" min="1" max="99" value="50">
          <div class="sub">현재 <b id="ml-thres-label">0.50</b> (추천: <span id="ml-thres-suggest">-</span>)</div>
        </div>
        <div class="sub">임곗값을 조정하면 혼동행렬과 정밀도/재현율이 즉시 반영됩니다.</div>
      </div>
    </div>

    <div class="results-grid">
      <!-- 1) 핵심 지표 -->
      <div class="panel">
        <div class="h2" style="font-size:16px;margin-bottom:6px">핵심 지표</div>
        <div class="table-wrap" style="max-height:260px">
          <table>
            <thead><tr><th>지표</th><th>값</th></tr></thead>
            <tbody id="ml-metrics"><tr><td>—</td><td>CSV 업로드 후 실행</td></tr></tbody>
          </table>
        </div>
      </div>

      <!-- 2) Confusion Matrix (분류) -->
      <div class="panel">
        <div class="h2" style="font-size:16px;margin-bottom:6px">Confusion Matrix</div>
        <div id="ml-cm" class="cm"></div>
      </div>

      <!-- 3) Feature Importance -->
      <div class="panel">
        <div class="h2" style="font-size:16px;margin-bottom:6px">Feature Importance</div>
        <div class="table-wrap" style="max-height:260px">
          <table>
            <thead><tr><th>Feature</th><th>Score</th></tr></thead>
            <tbody id="ml-vip"></tbody>
          </table>
        </div>
      </div>

      <!-- 4) 오분류/예측 미리보기 -->
      <div class="panel" style="grid-column: 1 / -1">
        <div class="h2" style="font-size:16px;margin-bottom:6px">오분류 사례 / 예측 미리보기</div>
        <div class="table-wrap" style="max-height:300px">
          <table>
            <thead><tr><th>#</th><th>True</th><th>Pred</th><th>Prob/Value</th></tr></thead>
            <tbody id="ml-preview"></tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- CTA -->
    <div class="cta-center">
      <a class="btn primary" href="https://prod.cloud.jamovi.kr/login/" target="_blank" rel="noopener">jamovi cloud 바로가기</a>
    </div>
  </div>
</section>

<!-- 라이브러리 -->
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.21.0/dist/tf.min.js"></script>

<script>
(function(){
  const $=s=>document.querySelector(s);
  const log=m=>{$('#ml-log').textContent='상태: '+m};

  const file=$('#ml-file'), chooseBtn=$('#ml-choose'), drop=$('#ml-drop');
  const fname=$('#ml-file-name'), fhint=$('#ml-file-hint');

  const targetSel=$('#ml-target'), predsBox=$('#ml-preds');
  const taskSel=$('#ml-task'), epochsEl=$('#ml-epochs'), batchEl=$('#ml-batch'), splitEl=$('#ml-split'), splitLbl=$('#ml-split-label');
  const trainBtn=$('#ml-train'), clearBtn=$('#ml-clear');
  const nrowEl=$('#ml-nrow'), ncolEl=$('#ml-ncol'), ntestEl=$('#ml-ntest');
  const metricsT=$('#ml-metrics'), cmBox=$('#ml-cm'), vipT=$('#ml-vip'), previewT=$('#ml-preview');
  const thWrap=$('#ml-thres-wrap'), thEl=$('#ml-thres'), thLbl=$('#ml-thres-label'), thSug=$('#ml-thres-suggest');

  let DATA=null, HEADERS=[];
  let CLF_INFO=null; // {ytrue, prob, testIdxArr, auc, suggestTh}

  splitEl?.addEventListener('input', e=> splitLbl.textContent = e.target.value + '%');

  function resetAll(){
    DATA=null; HEADERS=[]; CLF_INFO=null;
    fname.textContent='CSV 파일을 선택하거나 드롭하세요'; fhint.textContent='';
    nrowEl.textContent='-'; ncolEl.textContent='-'; ntestEl.textContent='-';
    targetSel.innerHTML=''; predsBox.innerHTML='';
    metricsT.innerHTML='<tr><td>—</td><td>CSV 업로드 후 실행</td></tr>';
    cmBox.innerHTML=''; vipT.innerHTML=''; previewT.innerHTML='';
    thWrap.style.display='none';
    trainBtn.disabled=true; clearBtn.disabled=true;
    log('대기');
  }
  $('#ml-clear')?.addEventListener('click', ()=>{ file.value=''; resetAll(); });
  resetAll();

  // ▶ 파일 선택 트리거
  chooseBtn.addEventListener('click', ()=> file.click());
  // 드롭존 아무 곳 클릭해도 파일창 열기 (버튼 영역 제외해도 괜찮지만 일단 허용)
  drop.addEventListener('click', e=>{ if(e.target.id!=='ml-choose') file.click(); });

  // 드래그&드롭
  ;['dragenter','dragover','dragleave','drop'].forEach(ev=> drop.addEventListener(ev, e=>{e.preventDefault();e.stopPropagation();}));
  drop.addEventListener('drop', (e)=>{ const f=e.dataTransfer.files?.[0]; if(f){ handleFile(f); } });

  // 파일 선택
  file.addEventListener('change', ()=>{ const f=file.files?.[0]; if(f){ handleFile(f); } });

  function handleFile(f){
    fname.textContent=f.name; fhint.textContent='읽는 중…'; log('CSV 파싱 중');
    Papa.parse(f, {
      header:true, dynamicTyping:true, skipEmptyLines:'greedy',
      delimiter:'', encoding:'UTF-8',
      worker:false,
      complete:onParsed,
      error:(err)=>{ fhint.textContent='CSV 파싱 실패: '+(err?.message||''); log('파싱 오류'); }
    });
  }

  function onParsed(res){
    try{
      if (!res || !Array.isArray(res.data)) { fhint.textContent='CSV 파싱 결과가 비었습니다.'; log('비어 있음'); return; }
      const rows = res.data.filter(r => r && Object.keys(r).length && !Object.values(r).every(v => v===''||v==null));
      const headers = (res.meta?.fields?.length? res.meta.fields : (rows[0]? Object.keys(rows[0]) : []));
      if (!rows.length || !headers.length){ fhint.textContent='유효한 데이터/헤더 없음'; log('헤더 없음'); return; }

      DATA=rows; HEADERS=headers;
      fhint.textContent=`행 ${rows.length.toLocaleString()} · 열 ${headers.length.toLocaleString()}`;
      nrowEl.textContent=rows.length.toLocaleString(); ncolEl.textContent=headers.length.toLocaleString();

      targetSel.innerHTML=''; headers.forEach(h=>{ const o=document.createElement('option'); o.value=o.textContent=h; targetSel.appendChild(o); });
      predsBox.innerHTML=''; headers.forEach(h=>{ const b=document.createElement('button'); b.type='button'; b.textContent=h; b.className='chip'; b.dataset.active='false';
        b.addEventListener('click',()=>{ b.dataset.active=(b.dataset.active==='false')?'true':'false'; b.classList.toggle('active'); }); predsBox.appendChild(b); });

      trainBtn.disabled=false; clearBtn.disabled=false; log('CSV 준비 완료');
    }catch(e){ fhint.textContent='파싱 처리 오류'; log('파싱 처리 오류'); console.error(e); }
  }

  function getPreds(){
    const acts=[...predsBox.querySelectorAll('.chip')].filter(b=> b.dataset.active==='true').map(b=> b.textContent);
    return acts.length?acts:HEADERS.filter(h=> h!==targetSel.value);
  }

  // === 전처리: 평균 대치 + Missing 카테고리 + 표준화 ===
  function toX(rows, cols){
    const isCat = c => typeof rows.find(r=> r[c]!==undefined && r[c]!==null && r[c]!=='' )?.[c] === 'string';
    const catCols = cols.filter(isCat);
    const numCols = cols.filter(c => !catCols.includes(c));

    const catMaps = {};
    catCols.forEach(c=>{
      const uniq = [...new Set(rows.map(r=> r[c]).map(v => (v===''||v==null)?'__MISSING__':String(v)))];
      catMaps[c] = uniq;
    });

    const means = {}, stds = {};
    numCols.forEach(c=>{
      const vals = rows.map(r=> parseFloat(r[c])).filter(v=> Number.isFinite(v));
      means[c] = vals.length ? vals.reduce((a,b)=>a+b,0)/vals.length : 0;
    });

    const raw = rows.map(r=>{
      const vec = [];
      numCols.forEach(c=>{
        const v = parseFloat(r[c]);
        vec.push(Number.isFinite(v) ? v : means[c]);
      });
      catCols.forEach(c=>{
        const cats = catMaps[c];
        const val  = (r[c]===''||r[c]==null) ? '__MISSING__' : String(r[c]);
        const idx  = cats.indexOf(val);
        const oh   = new Array(cats.length).fill(0);
        if(idx>=0) oh[idx]=1;
        vec.push(...oh);
      });
      return vec;
    });

    const dNum = numCols.length, n = raw.length;
    const mArr=new Array(dNum).fill(0), sArr=new Array(dNum).fill(0);
    for(let j=0;j<dNum;j++){ for(let i=0;i<n;i++) mArr[j]+=raw[i][j]; mArr[j]/=n; }
    for(let j=0;j<dNum;j++){ let s=0; for(let i=0;i<n;i++){ const d=raw[i][j]-mArr[j]; s+=d*d; } sArr[j]=Math.sqrt(s/Math.max(1,n-1))||1; }
    for(let i=0;i<n;i++){ for(let j=0;j<dNum;j++){ raw[i][j]=(raw[i][j]-mArr[j])/(sArr[j]||1); } }

    return tf.tensor2d(raw);
  }
  const yVec=(rows,t)=> rows.map(r=> r[t]);

  // Task 추론: 숫자 3종 이상 → 회귀, 그 외 → 이진 분류
  function inferTask(y){
    const u=[...new Set(y.filter(v=> v!==''&&v!=null))];
    const allNum=u.every(v=> typeof v==='number');
    if (!allNum) return 'bincls';
    return u.length > 2 ? 'reg' : 'bincls';
  }

  // ROC-AUC (이진)
  function rocAUC(y, p){
    const pairs = p.map((s,i)=>({s, y:y[i]})).sort((a,b)=>b.s-a.s);
    let tp=0, fp=0, fn=y.filter(v=>v===1).length, tn=y.length-fn;
    let prev=-1, auc=0, fprPrev=0, tprPrev=0;
    for(const r of pairs){
      if(r.s!==prev){
        const tpr = tp/Math.max(1, fn+tp);
        const fpr = fp/Math.max(1, fp+tn);
        auc += (fpr - fprPrev) * (tpr + tprPrev) / 2;
        fprPrev=fpr; tprPrev=tpr; prev=r.s;
      }
      if(r.y===1){ tp++; fn--; } else { fp++; tn--; }
    }
    const tpr = tp/Math.max(1, fn+tp), fpr = fp/Math.max(1, fp+tn);
    auc += (fpr - fprPrev) * (tpr + tprPrev) / 2;
    return Math.max(0, Math.min(1, auc));
  }

  // Youden J로 추천 임곗값
  function suggestThreshold(y, p){
    const uniq = Array.from(new Set(p)).sort((a,b)=>a-b);
    let bestT=0.5, bestJ=-1;
    for(const t of uniq){
      const yhat = p.map(v=> v>=t?1:0);
      let tp=0,fp=0,tn=0,fn=0;
      for(let i=0;i<yhat.length;i++){
        if(y[i]===1&&yhat[i]===1) tp++;
        else if(y[i]===0&&yhat[i]===0) tn++;
        else if(y[i]===0&&yhat[i]===1) fp++;
        else fn++;
      }
      const tpr = tp/Math.max(1, tp+fn);
      const fpr = fp/Math.max(1, fp+tn);
      const J = tpr - fpr;
      if(J>bestJ){ bestJ=J; bestT=t; }
    }
    return bestT;
  }

  async function updateClfViews(th){
    if(!CLF_INFO) return;
    const {ytrue, prob, testIdxArr, auc} = CLF_INFO;
    const yhat = prob.map(v=> v>=th?1:0);

    let tp=0,tn=0,fp=0,fn=0;
    for(let i=0;i<yhat.length;i++){
      if(ytrue[i]===1&&yhat[i]===1) tp++;
      else if(ytrue[i]===0&&yhat[i]===0) tn++;
      else if(ytrue[i]===0&&yhat[i]===1) fp++;
      else fn++;
    }
    const acc=yhat.filter((v,i)=>v===ytrue[i]).length/Math.max(1,yhat.length);
    const prec = tp / Math.max(1, tp+fp);
    const rec  = tp / Math.max(1, tp+fn);
    const f1   = (2*prec*rec) / Math.max(1e-9, (prec+rec));
    const posRate = ytrue.reduce((s,v)=>s+(v===1?1:0),0)/Math.max(1,ytrue.length);
    const tpr = tp/Math.max(1,tp+fn), tnr = tn/Math.max(1,tn+fp);
    const balAcc = (tpr + tnr)/2;

    metricsT.innerHTML =
      `<tr><td>Accuracy</td><td>${acc.toFixed(3)}</td></tr>
       <tr><td>Precision</td><td>${prec.toFixed(3)}</td></tr>
       <tr><td>Recall</td><td>${rec.toFixed(3)}</td></tr>
       <tr><td>F1</td><td>${f1.toFixed(3)}</td></tr>
       <tr><td>Balanced Accuracy</td><td>${balAcc.toFixed(3)}</td></tr>
       <tr><td>ROC-AUC</td><td>${auc.toFixed(3)}</td></tr>
       <tr><td>Positive rate (test)</td><td>${posRate.toFixed(3)}</td></tr>
       <tr><td>Test N</td><td>${yhat.length}</td></tr>`;

    cmBox.innerHTML=
      `<div><div class="sub">TN</div><div style="font-weight:800">${tn}</div></div>
       <div><div class="sub">FP</div><div style="font-weight:800">${fp}</div></div>
       <div><div class="sub">FN</div><div style="font-weight:800">${fn}</div></div>
       <div><div class="sub">TP</div><div style="font-weight:800">${tp}</div></div>`;

    // 오분류 표
    previewT.innerHTML='';
    const errs=[];
    for(let i=0;i<yhat.length;i++){
      if(yhat[i]!==ytrue[i]) errs.push({i,yt:ytrue[i],yh:yhat[i],pr:prob[i]});
    }
    if(errs.length===0){
      previewT.innerHTML='<tr><td colspan="4">오분류 없음 ✅</td></tr>';
    }else{
      const show = Math.min(20, errs.length);
      for(let k=0;k<show;k++){
        const e = errs[k]; const origIdx=testIdxArr[e.i];
        previewT.insertAdjacentHTML('beforeend',
          `<tr><td>${origIdx}</td><td>${e.yt}</td><td>${e.yh}</td><td>${e.pr.toFixed(3)}</td></tr>`);
      }
    }
  }
  thEl.addEventListener('input', ()=>{ const th=(+thEl.value)/100; thLbl.textContent=th.toFixed(2); updateClfViews(th); });

  $('#ml-train').addEventListener('click', async ()=>{
    if(!DATA){ alert('CSV를 먼저 불러오세요.'); return; }

    const target = targetSel.value;
    const predCols = getPreds();

    const split = parseInt(splitEl.value,10)/100;
    const epochs = parseInt(epochsEl.value,10);
    const batch  = parseInt(batchEl.value,10);

    const rows = DATA.filter(r=> r[target]!=='' && r[target]!=null);
    const yraw = yVec(rows,target);
    const task = (taskSel.value==='auto') ? inferTask(yraw) : taskSel.value;

    const X = toX(rows, predCols);
    let yTensor; let y;
    if(task==='bincls'){
      const uniq=[...new Set(yraw.map(v=> String(v)))];
      const pos=uniq[0]; // 기준 클래스(양성)
      y = yraw.map(v=> (String(v)===pos)?0:1);
      yTensor = tf.tensor2d(y.map(v=>[v]));
    } else {
      y = yraw.map(v=> parseFloat(v)||0);
      yTensor = tf.tensor2d(y.map(v=>[v]));
    }

    const n = X.shape[0];
    const nTrain = Math.max(10, Math.floor(n*split));
    const shuffled = tf.util.createShuffledIndices(n);
    const trainIdx = tf.tensor1d(Array.from(shuffled.slice(0, nTrain)), 'int32');
    const testIdx  = tf.tensor1d(Array.from(shuffled.slice(nTrain)),   'int32');

    const Xtr=tf.gather(X,trainIdx), Xte=tf.gather(X,testIdx), ytr=tf.gather(yTensor,trainIdx), yte=tf.gather(yTensor,testIdx);

    const model=tf.sequential(); const d=X.shape[1];
    model.add(tf.layers.dense({units:Math.min(32,Math.max(8,Math.round(d*0.75))), inputShape:[d], activation:'relu'}));
    if(d>12) model.add(tf.layers.dense({units:16,activation:'relu'}));
    if(task==='bincls'){ model.add(tf.layers.dense({units:1,activation:'sigmoid'})); model.compile({optimizer:tf.train.adam(),loss:'binaryCrossentropy',metrics:['accuracy']});
    } else { model.add(tf.layers.dense({units:1})); model.compile({optimizer:tf.train.adam(),loss:'mse',metrics:['mse']}); }

    $('#ml-progress').style.display='block'; log('학습 중…');
    await model.fit(Xtr,ytr,{epochs,batchSize:batch,shuffle:true,callbacks:{onEpochEnd:(e,l)=>{$('#ml-ptext').textContent=`epoch ${e+1}/${epochs} · loss ${l.loss.toFixed(4)}`;}}});
    $('#ml-progress').style.display='none';

    const pred=model.predict(Xte);
    ntestEl.textContent=(Xte.shape[0]||0).toLocaleString();

    if(task==='bincls'){
      const prob=(await pred.array()).map(v=>v[0]);
      const ytrue=(await yte.array()).map(v=>v[0]);
      const testIdxArr = await testIdx.array();
      const auc = rocAUC(ytrue, prob);
      const suggest = suggestThreshold(ytrue, prob);

      CLF_INFO={ytrue, prob, testIdxArr, auc, suggestTh:suggest};
      thWrap.style.display='block';
      thSug.textContent = suggest.toFixed(2);

      // 변수 중요도
      const w0=model.getWeights()[0];
      const arr=await w0.abs().sum(1).array();
      const vip=predCols.map((c,i)=>({name:c,score:(arr[i]||0)})).sort((a,b)=>b.score-a.score).slice(0,20);
      vipT.innerHTML=vip.map(r=>`<tr><td>${String(r.name).replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]))}</td><td>${r.score.toFixed(3)}</td></tr>`).join('');

      // 초기 임곗값(0.5)로 뷰 구성
      thEl.value = 50; thLbl.textContent='0.50';
      await updateClfViews(0.5);
      log('평가 완료(분류)');
    } else {
      const p=(await pred.array()).map(v=>v[0]); const ytrue=(await yte.array()).map(v=>v[0]);
      const mse=p.reduce((s,v,i)=> s+(v-ytrue[i])**2,0)/Math.max(1,p.length);
      const rmse=Math.sqrt(mse);
      const mae=p.reduce((s,v,i)=> s+Math.abs(v-ytrue[i]),0)/Math.max(1,p.length);
      const meanY = ytrue.reduce((s,v)=>s+v,0)/Math.max(1,ytrue.length);
      const sst = ytrue.reduce((s,v)=>s+(v-meanY)**2,0);
      const ssr = ytrue.reduce((s,v,i)=>s+(v-p[i])**2,0);
      const r2 = 1 - (ssr/Math.max(1e-9,sst));

      metricsT.innerHTML=
        `<tr><td>RMSE</td><td>${rmse.toFixed(3)}</td></tr>
         <tr><td>MAE</td><td>${mae.toFixed(3)}</td></tr>
         <tr><td>R²</td><td>${r2.toFixed(3)}</td></tr>
         <tr><td>Test N</td><td>${p.length}</td></tr>`;
      cmBox.innerHTML=`<div class="sub">회귀는 혼동행렬을 사용하지 않습니다.</div>`;
      thWrap.style.display='none';

      // 예측 미리보기
      previewT.innerHTML='';
      const show = Math.min(20, p.length);
      const testIdxArr = await testIdx.array();
      for(let i=0;i<show;i++){
        previewT.insertAdjacentHTML('beforeend',
          `<tr><td>${testIdxArr[i]}</td><td>${ytrue[i].toFixed(3)}</td><td>${p[i].toFixed(3)}</td><td>-</td></tr>`);
      }

      // 변수 중요도
      const w0=model.getWeights()[0];
      const arr=await w0.abs().sum(1).array();
      const vip=predCols.map((c,i)=>({name:c,score:(arr[i]||0)})).sort((a,b)=>b.score-a-score).slice(0,20);
      vipT.innerHTML=vip.map(r=>`<tr><td>${String(r.name).replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]))}</td><td>${r.score.toFixed(3)}</td></tr>`).join('');

      log('평가 완료(회귀)');
    }

    // 자원 정리
    trainIdx.dispose(); testIdx.dispose();
    X.dispose(); Xtr.dispose(); Xte.dispose(); yTensor.dispose(); ytr.dispose(); yte.dispose(); pred.dispose();
  });
})();
</script>
