<!-- ✅ SNOWSOFT | 간편 머신러닝 분석 (오른쪽 세로 '결과로 이동' 단일 버튼) -->
<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>SNOWSOFT | 간편 머신러닝 분석</title>

<style>
  @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@500;700;900&display=swap');

  html, body { margin:0; overflow-x:hidden; }
  .ml, .ml *{font-family:'Noto Sans KR','Apple SD Gothic Neo','Malgun Gothic',system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; box-sizing:border-box}
  .ml{
    --navy:#0f2e59; --cobalt:#174a8c; --text:#0F172A; --dim:#475569; --card:#fff; --br:#e6ecf4; --r-xl:20px;
    overflow-x:clip;
  }

  .ml .card{background:var(--card);border:1px solid var(--br);border-radius:var(--r-xl);max-width:1160px;margin:24px auto 22px;padding:20px 22px;color:var(--text);
    box-shadow:0 10px 32px rgba(16,24,40,.08)}
  .ml .h2{margin:0 0 14px;font-size:20px;font-weight:800;color:var(--navy)}
  .ml .sub{color:var(--dim);font-size:14px}
  .ml label{display:block;font-size:13px;color:#2b3345;margin-bottom:6px}
  .ml select,.ml input[type=number],.ml input[type=range]{width:100%;padding:10px 12px;border:1px solid #e5e7eb;border-radius:10px;background:#fff;font-size:14px}
  .ml .chips{display:flex;flex-wrap:wrap;gap:8px}
  .ml .chip{padding:6px 10px;border-radius:999px;border:1px solid #e5e7eb;font-size:12px;cursor:pointer}
  .ml .chip.active{background:#eef2ff;border-color:#c7d2fe}
  .ml .btn{appearance:none;border:1px solid #e5e7eb;background:#fff;border-radius:12px;padding:10px 14px;font-weight:800;font-size:14px;cursor:pointer;transition:.18s; text-decoration:none}
  .ml .btn:hover{transform:translateY(-1px);box-shadow:0 6px 16px rgba(0,0,0,.08)}
  .ml .btn.primary{color:#fff;background:linear-gradient(90deg,#0f2e59,#174a8c);border:none}
  .ml .btn.ghost{background:#fff;border-color:#e2e8f0}
  .ml .btn.ghost:hover{box-shadow:0 6px 16px rgba(2,6,23,.06)}

  .ml .uploader{
    position:relative;border:1px dashed #cbd5e1;border-radius:14px;background:#fafcff;padding:14px 16px;
    display:flex;align-items:center;justify-content:space-between;gap:12px
  }
  .ml .uploader-left{display:flex;align-items:center;gap:10px}
  .ml .uploader-icon{
    width:22px;height:22px;border-radius:8px;display:inline-flex;align-items:center;justify-content:center;
    background:#eef6ff;border:1px solid #dbeafe
  }
  .ml .uploader strong{font-weight:800}
  .ml .uploader small{color:#64748b}

  /* 패널/그리드 */
  .ml .panel{border:1px solid var(--br);border-radius:14px;padding:14px;min-width:0;min-height:0;display:flex;flex-direction:column}
  .ml .results{margin-top:18px}
  .ml .results-grid{
    display:grid;
    grid-template-columns:1.2fr 1fr 1fr;
    gap:16px;
    align-items:stretch;
  }
  @media (max-width:1100px){ .ml .results-grid{grid-template-columns:1fr 1fr} }
  @media (max-width:760px){ .ml .results-grid{grid-template-columns:1fr} }

  /* 표: 내부 스크롤 (세로/가로) — 가시성 유지 */
  .ml .table-wrap{
    border:1px solid #e9eef5; border-radius:14px;
    overflow:auto;
    max-height:360px;
    -webkit-overflow-scrolling:touch;
    scrollbar-width:auto;
    scrollbar-color:#94a3b8 #e2e8f0;
  }
  .ml table{width:100%; border-collapse:separate; border-spacing:0; font-size:14px; min-width:560px}
  .ml thead th{background:#f8fafc;color:#2b3345;font-weight:800;text-align:left;padding:10px;border-bottom:1px solid #e9eef5}
  .ml tbody td{padding:10px;border-top:1px solid #eef2f7; word-break:break-word}

  /* WebKit/Chromium 스크롤바 */
  .ml .table-wrap::-webkit-scrollbar{height:12px;width:12px}
  .ml .table-wrap::-webkit-scrollbar-thumb{background:#94a3b8;border-radius:999px;border:3px solid #e2e8f0}
  .ml .table-wrap::-webkit-scrollbar-track{background:#e2e8f0;border-radius:999px}

  /* Confusion Matrix */
  .ml .cm{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
  .ml .cm > div{border:1px solid #e5e7eb;border-radius:12px;padding:12px;text-align:center}
  .ml .cm .sub{font-size:11px;color:#64748b}

  .ml .log{margin-top:10px;border:1px dashed #cbd5e1;border-radius:12px;background:#fbfdff;padding:10px;font-size:12px;color:#0b1220;white-space:pre-wrap}

  /* ✅ 오른쪽 고정 세로 버튼 (결과 생성 후 표시) */
  .side-fab{
    position:fixed;
    right:18px;
    top:50%;
    transform:translateY(-50%);
    z-index:9999;
    display:none;               /* 학습 완료 전에는 숨김 */
    padding:14px 10px;
    width:44px;
    height:180px;
    writing-mode:vertical-rl;   /* 세로 글자 */
    text-orientation:mixed;
    border-radius:18px;
    font-weight:900;
    letter-spacing:0.5px;
    background:linear-gradient(180deg,#0f2e59,#174a8c);
    color:#fff;
    border:none;
    box-shadow:0 12px 28px rgba(2,6,23,.22);
    cursor:pointer;
    transition:transform .18s, box-shadow .18s, opacity .18s;
    opacity:.98;
  }
  .side-fab:hover{ transform:translateY(-50%) scale(1.02); box-shadow:0 16px 36px rgba(2,6,23,.28); }
  .side-fab:active{ transform:translateY(-50%) scale(0.99); }
  @media (max-width:960px){
    .side-fab{ right:10px; height:160px; }
  }
</style>
</head>
<body>

<section class="ml" id="ml-app">
  <!-- 입력 카드 -->
  <div class="card">
    <div class="h2">분석 시작</div>
    <p class="sub">CSV를 선택하면 아래 설정이 활성화됩니다. (데이터는 브라우저에서만 처리)</p>

    <div class="uploader" id="ml-drop">
      <div class="uploader-left">
        <span class="uploader-icon" aria-hidden="true">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path d="M12 16V4m0 0l-4 4m4-4l4 4" stroke="#0f2e59" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M20 16v3a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1v-3" stroke="#0f2e59" stroke-width="2" stroke-linecap="round"/>
          </svg>
        </span>
        <div>
          <strong id="ml-file-name">CSV 파일을 선택하거나 드롭하세요</strong><br>
          <small id="ml-file-hint"></small>
        </div>
      </div>
      <button type="button" class="btn ghost" id="ml-choose">파일 선택</button>
      <input id="ml-file" type="file" accept=".csv,text/csv" style="display:none" />
    </div>

    <div class="log" id="ml-log">상태: 대기</div>

    <div class="controls">
      <div class="panel">
        <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:12px">
          <div>
            <label>Task</label>
            <select id="ml-task">
              <option value="auto">Auto</option>
              <option value="bincls">Binary Classification</option>
              <option value="reg">Regression</option>
            </select>
          </div>
          <div><label>Iterations</label><input id="ml-epochs" type="number" value="30" min="1"></div>
          <div><label>Batch Size</label><input id="ml-batch" type="number" value="32" min="1"></div>
        </div>

        <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px">
          <div>
            <label>Train/Test Split</label>
            <input id="ml-split" type="range" min="50" max="90" value="80">
            <div style="display:flex;justify-content:space-between;font-size:12px;color:#64748b">
              <span>Train</span><span id="ml-split-label">80%</span><span>Test</span>
            </div>
          </div>
          <div><label>Target</label><select id="ml-target"></select></div>
        </div>

        <div style="margin-top:12px">
          <label>Features (if empty = all except target)</label>
          <div id="ml-preds" class="chips"></div>
        </div>

        <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:14px">
          <button id="ml-train" class="btn primary" disabled>학습 시작</button>
          <button id="ml-clear" class="btn" disabled>초기화</button>
          <div style="margin-left:auto"></div>
        </div>
        <div id="ml-progress" class="sub" style="margin-top:8px;display:none">학습 중… <span id="ml-ptext"></span></div>

        <div class="badges">
          <span class="badge">행 <b id="ml-nrow">-</b></span>
          <span class="badge">열 <b id="ml-ncol">-</b></span>
          <span class="badge">테스트 샘플 <b id="ml-ntest">-</b></span>
        </div>
      </div>
    </div>
  </div>

  <!-- 결과 카드 -->
  <div class="card results" id="ml-results-card">
    <div class="h2">결과</div>

    <!-- 임곗값 (분류일 때만) -->
    <div id="ml-thres-wrap" class="panel" style="display:none;margin-bottom:12px">
      <div style="display:flex;gap:18px;align-items:center;flex-wrap:wrap">
        <div style="min-width:220px">
          <label>Decision Threshold</label>
          <input id="ml-thres" type="range" min="1" max="99" value="50">
          <div class="sub">현재 <b id="ml-thres-label">0.50</b> (추천: <span id="ml-thres-suggest">-</span>)</div>
        </div>
        <div class="sub">임곗값을 조정하면 혼동행렬과 정밀도/재현율이 즉시 반영됩니다.</div>
      </div>
    </div>

    <div class="results-grid">
      <!-- 핵심 지표 -->
      <div class="panel">
        <div class="h2" style="font-size:16px;margin-bottom:6px">핵심 지표</div>
        <div class="table-wrap">
          <table>
            <thead><tr><th>지표</th><th>값</th></tr></thead>
            <tbody id="ml-metrics"><tr><td>—</td><td>CSV 업로드 후 실행</td></tr></tbody>
          </table>
        </div>
      </div>

      <!-- Confusion Matrix -->
      <div class="panel">
        <div class="h2" style="font-size:16px;margin-bottom:6px">Confusion Matrix</div>
        <div id="ml-cm" class="cm"></div>
      </div>

      <!-- 설명변수 중요도 -->
      <div class="panel">
        <div class="h2" style="font-size:16px;margin-bottom:6px">설명변수 중요도</div>
        <div class="table-wrap">
          <table>
            <thead><tr><th>설명변수</th><th>Score(|β| or |w|)</th></tr></thead>
            <tbody id="ml-vip"></tbody>
          </table>
        </div>
      </div>

      <!-- 계수/가중치 유의성 -->
      <div class="panel" style="grid-column: 1 / -1">
        <div class="h2" style="font-size:16px;margin-bottom:6px">계수/가중치 (표준화, 부트스트랩 유의성)</div>
        <div class="table-wrap">
          <table>
            <thead><tr><th>설명변수</th><th>계수/가중치</th><th>SE<sub>boot</sub></th><th>z</th><th>p</th><th>Sig.</th></tr></thead>
            <tbody id="ml-coef"></tbody>
          </table>
        </div>
      </div>

      <!-- 교차검증 요약 -->
      <div class="panel" style="grid-column: 1 / -1">
        <div class="h2" style="font-size:16px;margin-bottom:6px">5-Fold 교차검증 요약</div>
        <div class="table-wrap">
          <table>
            <thead id="ml-cv-head"></thead>
            <tbody id="ml-cv-body"></tbody>
          </table>
        </div>
      </div>

      <!-- 예측 미리보기 -->
      <div class="panel" style="grid-column: 1 / -1">
        <a id="ml-preview-anchor"></a>
        <div class="h2" style="font-size:16px;margin-bottom:6px">예측 미리보기</div>
        <div class="table-wrap">
          <table>
            <thead>
              <tr>
                <th style="min-width:120px">실제값</th>
                <th style="min-width:120px">예측값</th>
                <th style="min-width:140px">예측확률/예측치</th>
                <th>설명변수 (상위 몇 개)</th>
              </tr>
            </thead>
            <tbody id="ml-preview"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <!-- ✅ 오른쪽 세로 이동 버튼 (학습 완료 후 표시) -->
  <button id="ml-goto-results" class="side-fab" aria-label="결과로 이동">결과로 이동</button>
</section>

<script>
(() => {
  /* ====== 설정 ====== */
  const B_AUC  = 200;  // AUC CI bootstrap
  const B_COEF = 200;  // Coef SE bootstrap

  const $ = (sel) => document.querySelector(sel);
  const log = (msg) => { const el = $('#ml-log'); el.textContent = '상태: ' + msg; };

  /* ---------- 유틸 ---------- */
  const escapeHtml = (s)=> String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  function mean(arr){ return arr.reduce((a,b)=>a+b,0)/Math.max(1,arr.length); }
  function sd(arr){ const m=mean(arr); let v=0; for(const x of arr) v+=(x-m)**2; return Math.sqrt(v/Math.max(1,arr.length-1)); }
  function quantile(arr, q){ const a=arr.slice().sort((x,y)=>x-y); const pos=(a.length-1)*q; const lo=Math.floor(pos), hi=Math.ceil(pos); if(lo===hi) return a[lo]; return a[lo]*(hi-pos)+a[hi]*(pos-lo); }
  function erf(x){ const s=Math.sign(x), t=1/(1+0.3275911*Math.abs(x));
    const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429;
    const y=1-(((((a5*t+a4)*t)+a3)*t+a2)*t+a1)*t*Math.exp(-x*x);
    return s*y;
  }
  function pnorm(z){ return 0.5*(1+erf(z/Math.SQRT2)); }
  function twoSidedP(z){ const az=Math.abs(z); return 2*(1-pnorm(az)); }
  function stars(p){ return p<0.001?'***': p<0.01?'**': p<0.05?'*': p<0.1?'.':''; }

  /* ---------- CSV ---------- */
  function parseCSV(text) {
    const lines = text.replace(/\r/g,'').split('\n').filter(l => l.trim().length);
    const split = (line) => {
      const res = []; let cur = '', inQ = false;
      for (let i=0;i<line.length;i++){
        const c=line[i];
        if (c === '"'){ if (inQ && line[i+1] === '"'){ cur+='"'; i++; } else inQ=!inQ; }
        else if (c === ',' && !inQ){ res.push(cur); cur=''; }
        else cur += c;
      }
      res.push(cur); return res;
    };
    const headers = split(lines[0]).map(h => h.trim());
    const rows = [];
    for (let i=1;i<lines.length;i++){
      const row = split(lines[i]); const obj = {};
      headers.forEach((h,idx)=> obj[h] = row[idx] ?? '');
      rows.push(obj);
    }
    return { headers, rows };
  }
  const isNumericArray = (arr)=> {
    let num=0, ne=0; for (const v of arr){ if (v===''||v==null) continue; ne++; if (!isNaN(parseFloat(v))) num++; }
    return num/Math.max(ne,1) > 0.9;
  };
  const toNumberOrNa = (v)=> (v===''||v==null)? NaN : (isNaN(+v)? NaN : +v);
  const median = (a)=>{ const b=a.filter(x=>!isNaN(x)).sort((x,y)=>x-y); if(!b.length) return NaN; const m=Math.floor(b.length/2); return b.length%2? b[m] : (b[m-1]+b[m])/2; };
  const mode = (arr)=>{ const m=new Map(); for(const v of arr){ const k=(v===''||v==null)?'__NA__':String(v); m.set(k,(m.get(k)||0)+1); } let best='__NA__',c=-1; m.forEach((n,k)=>{if(n>c){c=n;best=k;}}); return best==='__NA__'? '' : best; };

  /* ---------- split/scale ---------- */
  function trainTestSplit(X, y, testRatio=0.2, seed=42){
    const n=X.length, idx=Array.from({length:n},(_,i)=>i); let s=seed;
    idx.sort(()=>{ s=(s*9301+49297)%233280; return (s/233280)-0.5; });
    const nTest=Math.max(1,Math.round(n*testRatio)), test=new Set(idx.slice(0,nTest));
    const Xtr=[],ytr=[],Xte=[],yte=[]; idx.forEach(i=> test.has(i)? (Xte.push(X[i]),yte.push(y[i])) : (Xtr.push(X[i]),ytr.push(y[i])));
    return { Xtr,ytr,Xte,yte };
  }
  function standardizeFit(X){
    const p=X[0].length, mu=Array(p).fill(0), sdv=Array(p).fill(0);
    for(let j=0;j<p;j++){
      let s=0,c=0; for(let i=0;i<X.length;i++){ const v=X[i][j]; if(!isNaN(v)){ s+=v; c++; } }
      mu[j]=c? s/c : 0; let v=0,cc=0; for(let i=0;i<X.length;i++){ const x=X[i][j]; if(!isNaN(x)){ v+=(x-mu[j])**2; cc++; } }
      sdv[j]=cc? Math.sqrt(v/cc)||1 : 1;
    }
    const transform=(Z)=> Z.map(r=> r.map((v,j)=> isNaN(v)?0:(v-mu[j])/sdv[j]));
    return { mu:mu, sd:sdv, transform };
  }

  /* ---------- models ---------- */
  const dot=(a,b)=>{let s=0; for(let i=0;i<a.length;i++) s+=(a[i]||0)*(b[i]||0); return s; };
  const sigmoid=(z)=> 1/(1+Math.exp(-z));

  function fitLinear(X,y,iterations=200,lr=0.05,l2=1e-4,cb){
    const n=X.length,p=X[0].length; const w=Array(p).fill(0); let b=0;
    for(let it=1;it<=iterations;it++){
      let db=0; const dw=Array(p).fill(0);
      for(let i=0;i<n;i++){ const yhat=dot(w,X[i])+b; const e=yhat-y[i]; db+=e; for(let j=0;j<p;j++) dw[j]+=e*X[i][j]; }
      for(let j=0;j<p;j++) w[j]-=lr*((dw[j]/n)+l2*w[j]); b-=lr*(db/n);
      if(cb && it%10===0) cb(it);
    }
    const predict=(Z)=> Z.map(r=> dot(w,r)+b);
    return { w,b,predict, iterations };
  }

  function fitLogistic(X,y,iterations=400,lr=0.08,l2=1e-4,cb){
    const n=X.length,p=X[0].length; const w=Array(p).fill(0); let b=0;
    for(let it=1;it<=iterations;it++){
      let db=0; const dw=Array(p).fill(0);
      for(let i=0;i<n;i++){ const z=dot(w,X[i])+b; const p1=sigmoid(z); const e=p1-y[i]; db+=e; for(let j=0;j<p;j++) dw[j]+=e*X[i][j]; }
      for(let j=0;j<p;j++) w[j]-=lr*((dw[j]/n)+l2*w[j]); b-=lr*(db/n);
      if(cb && it%20===0) cb(it);
    }
    const predictProba=(Z)=> Z.map(r=> sigmoid(dot(w,r)+b));
    const predict=(Z,thr=0.5)=> predictProba(Z).map(p=> p>=thr?1:0);
    return { w,b,predictProba,predict, iterations };
  }

  /* ---------- OLS ridge ---------- */
  function ridgeClosedForm(X, y, l2=1e-4){
    const p = X[0].length;
    const XtX = Array.from({length:p},()=>Array(p).fill(0));
    const Xty = Array(p).fill(0);
    for(let i=0;i<X.length;i++){
      const r=X[i]; const yi=y[i];
      for(let j=0;j<p;j++){
        Xty[j]+=r[j]*yi;
        const rj=r[j];
        for(let k=0;k<p;k++) XtX[j][k]+=rj*r[k];
      }
    }
    for(let j=0;j<p;j++) XtX[j][j]+=l2;

    const A = XtX.map(row=>row.slice()); const b = Xty.slice();
    for(let i=0;i<p;i++){
      let max=i; for(let r=i+1;r<p;r++) if(Math.abs(A[r][i])>Math.abs(A[max][i])) max=r;
      if(max!==i){ const tmp=A[i]; A[i]=A[max]; A[max]=tmp; const tb=b[i]; b[i]=b[max]; b[max]=tb; }
      const piv=A[i][i]||1e-12;
      for(let r=i+1;r<p;r++){
        const f=A[r][i]/piv;
        if(!isFinite(f)) continue;
        for(let c=i;c<p;c++) A[r][c]-=f*A[i][c];
        b[r]-=f*b[i];
      }
    }
    const w=Array(p).fill(0);
    for(let i=p-1;i>=0;i--){
      let s=b[i];
      for(let c=i+1;c<p;c++) s-=A[i][c]*w[c];
      w[i]=s/(A[i][i]||1e-12);
    }
    return w;
  }

  /* ---------- metrics ---------- */
  const mse=(y,yhat)=>{let s=0; for(let i=0;i<y.length;i++){ const e=yhat[i]-y[i]; s+=e*e; } return s/Math.max(1,y.length); };
  function binMetrics(yTrue,yProb,thr=0.5){
    const yPred=yProb.map(p=> p>=thr?1:0);
    let tp=0,tn=0,fp=0,fn=0;
    for(let i=0;i<yTrue.length;i++){
      const yt=yTrue[i], yp=yPred[i];
      if(yt===1 && yp===1) tp++;
      else if(yt===0 && yp===0) tn++;
      else if(yt===0 && yp===1) fp++;
      else if(yt===1 && yp===0) fn++;
    }
    const acc=(tp+tn)/Math.max(1,yTrue.length);
    const prec=tp/Math.max(1,tp+fp);
    const rec=tp/Math.max(1,tp+fn);
    const f1=(prec+rec)? (2*prec*rec/(prec+rec)) : 0;
    return { tp,tn,fp,fn,acc,prec,rec,f1,yPred };
  }

  /* ---------- ROC/AUC & AUC CI ---------- */
  function computeROC(yTrue, yProb) {
    const uniq = Array.from(new Set(yProb.concat([0, 1]))).sort((a,b)=>b-a);
    const pts = [];
    let bestJ = -Infinity, bestThr = 0.5;
    for (const thr of uniq) {
      const {tp, tn, fp, fn} = binMetrics(yTrue, yProb, thr);
      const tpr = tp / Math.max(1, tp + fn);
      const fpr = fp / Math.max(1, fp + tn);
      const J = tpr - fpr;
      if (J > bestJ) { bestThr = thr; bestJ = J; }
      pts.push({fpr, tpr});
    }
    const sorted = pts.slice().sort((a,b)=> a.fpr - b.fpr);
    let auc = 0;
    for (let i=1;i<sorted.length;i++){
      const x1 = sorted[i-1].fpr, y1 = sorted[i-1].tpr;
      const x2 = sorted[i].fpr,   y2 = sorted[i].tpr;
      auc += (x2 - x1) * (y1 + y2) / 2;
    }
    return { auc, bestThr: Math.min(0.99, Math.max(0.01, bestThr)), points: sorted };
  }

  function bootstrapAucCI(y, prob, B=200, alpha=0.05){
    const n=y.length, aucs=[];
    for(let b=0;b<B;b++){
      const idx=[]; for(let i=0;i<n;i++) idx.push(Math.floor(Math.random()*n));
      const yb=idx.map(i=>y[i]); const pb=idx.map(i=>prob[i]);
      const {auc}=computeROC(yb,pb); aucs.push(auc);
    }
    const lo=quantile(aucs, alpha/2), hi=quantile(aucs, 1-alpha/2);
    return {lo, hi, B};
  }

  /* ---------- K-Fold CV ---------- */
  function kfoldIndices(n, k=5, seed=123) {
    const idx = Array.from({length:n}, (_,i)=>i);
    let s=seed;
    idx.sort(()=>{ s=(s*1103515245+12345)%2147483648; return (s/2147483648)-0.5; });
    const folds = Array.from({length:k}, ()=>[]);
    for (let i=0;i<n;i++) folds[i%k].push(idx[i]);
    return folds;
  }
  function cvEvaluate(X, y, task='bincls', k=5){
    const folds = kfoldIndices(X.length, k);
    const metrics = [];
    for (let f=0; f<k; f++){
      const testSet = new Set(folds[f]);
      const Xtr=[], ytr=[], Xte=[], yte=[];
      for (let i=0;i<X.length;i++){
        if (testSet.has(i)) { Xte.push(X[i]); yte.push(y[i]); }
        else { Xtr.push(X[i]); ytr.push(y[i]); }
      }
      const scaler=standardizeFit(Xtr); const XtrS=scaler.transform(Xtr); const XteS=scaler.transform(Xte);
      if (task==='bincls'){
        const model = fitLogistic(XtrS, ytr, 200, 0.08, 1e-4);
        const prob = model.predictProba(XteS);
        const {acc,prec,rec,f1} = binMetrics(yte, prob, 0.5);
        const {auc} = computeROC(yte, prob);
        metrics.push({acc, f1, auc});
      } else {
        const w = ridgeClosedForm(XtrS, ytr, 1e-4);
        const pred = XteS.map(r=>dot(w,r));
        const _mse = mse(yte, pred), rmse=Math.sqrt(_mse);
        const meanY = yte.reduce((a,b)=>a+b,0)/Math.max(1,yte.length);
        let ssTot=0,ssRes=0; for(let i=0;i<yte.length;i++){ ssRes+=(yte[i]-pred[i])**2; ssTot+=(yte[i]-meanY)**2; }
        const r2 = 1 - (ssRes/Math.max(ssTot,1e-12));
        metrics.push({rmse, r2});
      }
    }
    if (task==='bincls'){
      const accs = metrics.map(m=>m.acc), f1s=metrics.map(m=>m.f1), aucs=metrics.map(m=>m.auc);
      return {acc:{m:mean(accs), s:sd(accs)}, f1:{m:mean(f1s), s:sd(f1s)}, auc:{m:mean(aucs), s:sd(aucs)}};
    }else{
      const rmses = metrics.map(m=>m.rmse), r2s=metrics.map(m=>m.r2);
      return {rmse:{m:mean(rmses), s:sd(r2s)}, r2:{m:mean(r2s), s:sd(r2s)}};
    }
  }

  /* ---------- 부트스트랩: 계수(로지스틱/OLS) ---------- */
  function bootstrapCoefLogit(X, y, p, B=200){
    const n = X.length;
    const W = Array.from({length:B}, ()=>Array(p).fill(0));
    for(let b=0;b<B;b++){
      const idx = Array.from({length:n}, ()=> Math.floor(Math.random()*n));
      const Xb = idx.map(i=>X[i]);
      const yb = idx.map(i=>y[i]);
      const m = fitLogistic(Xb, yb, 200, 0.08, 1e-4);
      for(let j=0;j<p;j++) W[b][j] = m.w[j] || 0;
    }
    const se = Array(p).fill(0), z = Array(p).fill(NaN), pval = Array(p).fill(NaN);
    for(let j=0;j<p;j++){
      const col = W.map(r=>r[j]);
      se[j] = sd(col) || NaN;
    }
    return { se, z, p:pval };
  }

  function bootstrapCoefOLS(X, y, p, B=200){
    const n = X.length;
    const W = Array.from({length:B}, ()=>Array(p).fill(0));
    for(let b=0;b<B;b++){
      const idx = Array.from({length:n}, ()=> Math.floor(Math.random()*n));
      const Xb = idx.map(i=>X[i]);
      const yb = idx.map(i=>y[i]);
      const m = fitLinear(Xb, yb, 200, 0.05, 1e-4);
      for(let j=0;j<p;j++) W[b][j] = m.w[j] || 0;
    }
    const se = Array(p).fill(0);
    for(let j=0;j<p;j++){
      const col = W.map(r=>r[j]);
      se[j] = sd(col) || NaN;
    }
    return { se, z:Array(p).fill(NaN), p:Array(p).fill(NaN) };
  }

  /* ---------- state & DOM ---------- */
  let RAW=null;
  let META={ headers:[], numericCols:[], catCols:[], impute:{}, chosenTarget:null, chosenFeatures:[], task:'auto',
    mapTarget:null, invMapTarget:null, scaler:null, model:null, isClassification:false, splitRatio:0.8 };

  const fInput = $('#ml-file');
  const chooseBtn = $('#ml-choose');
  const targetSel = $('#ml-target');
  const predsWrap = $('#ml-preds');
  const splitRange = $('#ml-split');
  const splitLabel = $('#ml-split-label');
  const trainBtn = $('#ml-train');
  const clearBtn = $('#ml-clear');

  const nrowBadge = $('#ml-nrow');
  const ncolBadge = $('#ml-ncol');
  const ntestBadge = $('#ml-ntest');

  const thresWrap = $('#ml-thres-wrap');
  const thresInput = $('#ml-thres');
  const thresLabel = $('#ml-thres-label');

  const metricsBody = $('#ml-metrics');
  const cmDiv = $('#ml-cm');
  const vipBody = $('#ml-vip');
  const coefBody = $('#ml-coef');
  const previewBody = $('#ml-preview');

  const pWrap = $('#ml-progress');
  const pText = $('#ml-ptext');

  const cvHead = $('#ml-cv-head');
  const cvBody = $('#ml-cv-body');

  const gotoBtn = $('#ml-goto-results');

  chooseBtn.addEventListener('click', ()=> fInput.click());
  $('#ml-drop').addEventListener('dragover', (e)=> e.preventDefault());
  $('#ml-drop').addEventListener('drop', (e)=>{
    e.preventDefault();
    if (e.dataTransfer.files && e.dataTransfer.files[0]){ fInput.files=e.dataTransfer.files; handleFile(); }
  });
  fInput.addEventListener('change', handleFile);

  function handleFile(){
    const file = fInput.files && fInput.files[0]; if(!file) return;
    $('#ml-file-name').textContent = file.name;
    $('#ml-file-hint').textContent = `${(file.size/1024).toFixed(1)} KB`;
    const reader = new FileReader();
    reader.onload = ()=>{
      try{
        log('CSV 파싱 중…');
        const { headers, rows } = parseCSV(reader.result);
        RAW = { headers, rows }; resetUIAfterLoad(headers, rows); log('CSV 로드 완료');
      }catch(err){ console.error(err); log('CSV 파싱 오류'); }
    };
    reader.readAsText(file, 'utf-8');
  }

  function resetUIAfterLoad(headers, rows){
    const colData={}; headers.forEach(h=> colData[h]=rows.map(r=>r[h]));
    const numericCols=[], catCols=[];
    headers.forEach(h=> (isNumericArray(colData[h])? numericCols:catCols).push(h));

    META.headers=headers; META.numericCols=numericCols; META.catCols=catCols; META.impute={};
    for(const h of numericCols){ META.impute[h]={type:'num', value: median(colData[h].map(toNumberOrNa))}; }
    for(const h of catCols){ META.impute[h]={type:'cat', value: mode(colData[h])}; }

    targetSel.innerHTML = headers.map(h=>`<option value="${h}">${h}</option>`).join('');
    targetSel.value = headers[headers.length-1];
    META.chosenTarget = targetSel.value;

    renderFeatureChips();

    nrowBadge.textContent = rows.length;
    ncolBadge.textContent = headers.length;
    updateSplitLabel();

    trainBtn.disabled = false; clearBtn.disabled = false;

    metricsBody.innerHTML = `<tr><td>—</td><td>CSV 업로드 후 실행</td></tr>`;
    cmDiv.innerHTML = ''; vipBody.innerHTML = ''; coefBody.innerHTML=''; previewBody.innerHTML = '';
    thresWrap.style.display = 'none'; pWrap.style.display = 'none';
    cvHead.innerHTML=''; cvBody.innerHTML='';
    gotoBtn.style.display='none';                 // 새 파일 로드시 숨김
  }

  function renderFeatureChips(){
    const feats = META.headers.filter(h => h!==META.chosenTarget);
    META.chosenFeatures = feats.slice();
    predsWrap.innerHTML = feats.map(h=>`<span class="chip active" data-k="${h}">${h}</span>`).join('');
    predsWrap.querySelectorAll('.chip').forEach(chip=>{
      chip.addEventListener('click', ()=>{
        const k=chip.dataset.k; const on=chip.classList.toggle('active');
        if(on){ if(!META.chosenFeatures.includes(k)) META.chosenFeatures.push(k); }
        else META.chosenFeatures = META.chosenFeatures.filter(x=>x!==k);
      });
    });
  }
  targetSel.addEventListener('change', ()=>{ META.chosenTarget=targetSel.value; renderFeatureChips(); });
  function updateSplitLabel(){ const v=Number(splitRange.value); splitLabel.textContent=`${v}%`; META.splitRatio=v/100; }
  splitRange.addEventListener('input', updateSplitLabel);

  $('#ml-thres').addEventListener('input', ()=>{
    const thr = Number(thresInput.value)/100; document.getElementById('ml-thres-label').textContent = thr.toFixed(2);
    if (META.isClassification && META._lastProb) applyClassificationOutputs(META._lastYtrue, META._lastProb, thr);
  });

  $('#ml-clear').addEventListener('click', ()=>{
    RAW=null; META={ headers:[], numericCols:[], catCols:[], impute:{}, chosenTarget:null, chosenFeatures:[], task:'auto',
      mapTarget:null, invMapTarget:null, scaler:null, model:null, isClassification:false, splitRatio:0.8 };
    $('#ml-file').value=''; $('#ml-file-name').textContent='CSV 파일을 선택하거나 드롭하세요'; $('#ml-file-hint').textContent='';
    targetSel.innerHTML=''; predsWrap.innerHTML='';
    metricsBody.innerHTML=`<tr><td>—</td><td>CSV 업로드 후 실행</td></tr>`; cmDiv.innerHTML=''; vipBody.innerHTML=''; coefBody.innerHTML=''; previewBody.innerHTML='';
    nrowBadge.textContent='-'; ncolBadge.textContent='-'; ntestBadge.textContent='-'; thresWrap.style.display='none'; pWrap.style.display='none';
    cvHead.innerHTML=''; cvBody.innerHTML='';
    gotoBtn.style.display='none';                 // 초기화 시 숨김
    log('대기');
  });

  $('#ml-task').addEventListener('change', ()=> META.task = $('#ml-task').value);

  /* ---------- train ---------- */
  $('#ml-train').addEventListener('click', async ()=>{
    try{
      if(!RAW) return;
      const rows=RAW.rows.slice();
      const target=META.chosenTarget;
      const features=(META.chosenFeatures && META.chosenFeatures.length)? META.chosenFeatures : RAW.headers.filter(h=>h!==target);

      log('전처리 중…'); pWrap.style.display='block'; pText.textContent='전처리';
      const Xraw = rows.map(r => features.map(h => toNumberOrNa(r[h])));
      const medEach = []; for(let j=0;j<features.length;j++){ medEach[j] = median(Xraw.map(r=>r[j])); }
      const X = Xraw.map(r => r.map((v,j)=> isNaN(v)? medEach[j] : v));

      const ycol = rows.map(r => r[target]);
      let y=[], isClassification=false;

      if (META.task==='reg'){ isClassification=false; y=ycol.map(v=>toNumberOrNa(v)); }
      else if (META.task==='bincls'){ isClassification=true; }
      else { const uniq=Array.from(new Set(ycol.map(v=>String(v)))); isClassification = uniq.length <= Math.max(2, Math.sqrt(rows.length)/2); }

      if (isClassification){
        const uniq = Array.from(new Set(ycol.map(v=> String(v)))).filter(x=>x!=='');
        if (uniq.length<2){ alert('분류 수행 불가: 타깃 값이 한 종류입니다.'); pWrap.style.display='none'; return; }
        const cls = uniq.slice(0,2); const map={}, inv={}; map[cls[0]]=0; map[cls[1]]=1; inv[0]=cls[0]; inv[1]=cls[1];
        y = ycol.map(v => map[String(v)] ?? 0); META.mapTarget=map; META.invMapTarget=inv;
      }else{
        y = ycol.map(v=>toNumberOrNa(v));
        const keep=[]; for(let i=0;i<y.length;i++) if(!isNaN(y[i])) keep.push(i);
        const Xk=keep.map(i=>X[i]), yk=keep.map(i=>y[i]); X.length=0; y.length=0; X.push(...Xk); y.push(...yk);
        META.mapTarget=null; META.invMapTarget=null;
      }

      const scaler = standardizeFit(X); const Xs = scaler.transform(X);

      // CV
      log('교차검증 중…'); pText.textContent='5-Fold CV';
      const cv = cvEvaluate(Xs, y, isClassification?'bincls':'reg', 5);
      renderCV(cv, isClassification);

      // Hold-out split
      const { Xtr,ytr,Xte,yte } = trainTestSplit(Xs, y, 1-META.splitRatio);
      document.getElementById('ml-ntest').textContent = yte.length;

      META.isClassification = isClassification;
      const iterations = Math.max(20, Math.min(2000, parseInt(document.getElementById('ml-epochs').value||0,10)||30));

      if (isClassification){
        log('분류 학습 중…'); pText.textContent=`분류 반복`;
        const model = fitLogistic(Xtr, ytr, iterations, 0.08, 1e-4, (it)=> pText.textContent=`분류 반복 ${it}/${iterations}`);
        const prob = model.predictProba(Xte);
        META._lastProb=prob; META._lastYtrue=yte; META.model=model; META.scaler=scaler;
        thresWrap.style.display='';
        applyClassificationOutputs(yte, prob, 0.5, {features, inv:META.invMapTarget});
        renderVIP(features, model.w);

        // AUC CI
        log('AUC CI 계산…'); pText.textContent='AUC CI (bootstrap)';
        const aucCI = bootstrapAucCI(yte, prob, B_AUC, 0.05);
        const tb = document.getElementById('ml-metrics');
        tb.innerHTML += `<tr><td>AUC 95% CI (B=${aucCI.B})</td><td>[${aucCI.lo.toFixed(4)}, ${aucCI.hi.toFixed(4)}]</td></tr>`;

        // Coef bootstrap
        log('계수 부트스트랩…'); pText.textContent='Coef bootstrap';
        const coefBoot = bootstrapCoefLogit(Xtr, ytr, features.length, B_COEF);
        renderCoef(features, model.w, coefBoot.se, coefBoot.z, coefBoot.p);

        // 추천 임곗값
        const rc = computeROC(yte, prob);
        const v = Math.round(Math.max(1, Math.min(99, rc.bestThr*100)));
        document.getElementById('ml-thres').value = String(v);
        document.getElementById('ml-thres-label').textContent = (v/100).toFixed(2);

        // 클래스 비율
        const posRate = (y.reduce((a,b)=>a+(b===1?1:0),0)/Math.max(1,y.length));
        tb.innerHTML += `<tr><td>Positive Rate</td><td>${posRate.toFixed(4)}</td></tr>`;
      }else{
        log('회귀 학습 중…'); pText.textContent=`회귀 반복`;
        const model = fitLinear(Xtr, ytr, iterations, 0.05, 1e-4, (it)=> pText.textContent=`회귀 반복 ${it}/${iterations}`);
        const pred = model.predict(Xte);
        META.model=model; META.scaler=scaler;
        thresWrap.style.display='none';
        renderRegMetrics(yte, pred);
        renderPreviewRegression(yte, pred, features);

        // Coef bootstrap
        log('계수 부트스트랩…'); pText.textContent='Coef bootstrap';
        const coefBoot = bootstrapCoefOLS(Xtr, ytr, features.length, B_COEF);
        renderCoef(features, model.w, coefBoot.se, coefBoot.z, coefBoot.p);
      }

      log('완료'); pWrap.style.display='none';

      /* ✅ 결과가 생성되면 오른쪽 세로 버튼 표시 */
      gotoBtn.style.display='inline-flex';
      gotoBtn.onclick = () => document.querySelector('#ml-results-card')?.scrollIntoView({behavior:'smooth', block:'start'});
      // 최초 1회 자동 포커스 이동(UX): 프리뷰 근처로
      document.querySelector('#ml-preview-anchor')?.scrollIntoView({behavior:'smooth', block:'start'});
    }catch(err){
      console.error(err); log('오류: ' + (err?.message || err)); pWrap.style.display='none';
      gotoBtn.style.display='none';
    }
  });

  /* ---------- render helpers ---------- */
  function applyClassificationOutputs(yTrue, yProb, thr=0.5, extra){
    const { tp,tn,fp,fn,acc,prec,rec,f1,yPred } = binMetrics(yTrue,yProb,thr);
    const { auc } = computeROC(yTrue, yProb);

    document.getElementById('ml-metrics').innerHTML = `
      <tr><td>Accuracy</td><td>${acc.toFixed(4)}</td></tr>
      <tr><td>Precision</td><td>${prec.toFixed(4)}</td></tr>
      <tr><td>Recall</td><td>${rec.toFixed(4)}</td></tr>
      <tr><td>F1</td><td>${f1.toFixed(4)}</td></tr>
      <tr><td>AUC</td><td>${auc.toFixed(4)}</td></tr>
      <tr><td>Threshold</td><td>${thr.toFixed(2)}</td></tr>`;

    document.getElementById('ml-cm').innerHTML = `
      <div><div class="sub">TN</div><div style="font-weight:800;font-size:18px">${tn}</div></div>
      <div><div class="sub">FP</div><div style="font-weight:800;font-size:18px">${fp}</div></div>
      <div><div class="sub">FN</div><div style="font-weight:800;font-size:18px">${fn}</div></div>
      <div><div class="sub">TP</div><div style="font-weight:800;font-size:18px">${tp}</div></div>`;

    renderPreviewClassification(yTrue,yPred,yProb, extra?.features||[], extra?.inv||{});
  }

  function renderVIP(features, weights){
    const items = features.map((f,i)=>({ f, s: Math.abs(weights[i]||0) }))
                         .sort((a,b)=> b.s-a.s).slice(0, Math.min(20, features.length));
    document.getElementById('ml-vip').innerHTML =
      items.map(it=> `<tr><td>${escapeHtml(it.f)}</td><td>${it.s.toFixed(6)}</td></tr>`).join('') || `<tr><td colspan="2">-</td></tr>`;
  }

  function renderCoef(features, weights, seArr, zArr, pArr){
    const rows = features.map((f,i)=> {
      const w = (weights?.[i]||0);
      const se= seArr?.[i] ?? NaN;
      const z = zArr?.[i] ?? (isFinite(se)&&se>0 ? w/se : NaN);
      const p = pArr?.[i] ?? (isFinite(z)? twoSidedP(z) : NaN);
      const sig = isFinite(p) ? stars(p) : '';
      return `<tr>
        <td>${escapeHtml(f)}</td>
        <td>${w.toFixed(6)}</td>
        <td>${isFinite(se)? se.toFixed(6) : '-'}</td>
        <td>${isFinite(z)? z.toFixed(3) : '-'}</td>
        <td>${isFinite(p)? p.toExponential(2) : '-'}</td>
        <td>${sig}</td>
      </tr>`;
    });
    document.getElementById('ml-coef').innerHTML = rows.join('') || `<tr><td colspan="6">-</td></tr>`;
  }

  function renderPreviewClassification(yTrue, yPred, yProb, features, inv){
    const topNames = features.slice(0,3).join(', ');
    const rows = [];
    for (let i=0;i<yTrue.length;i++){
      rows.push(`<tr>
        <td>${escapeHtml(inv?.[yTrue[i]] ?? String(yTrue[i]))}</td>
        <td>${escapeHtml(inv?.[yPred[i]] ?? String(yPred[i]))}</td>
        <td>${(yProb[i]??0).toFixed(4)}</td>
        <td>${escapeHtml(topNames)}</td>
      </tr>`);
    }
    document.getElementById('ml-preview').innerHTML = rows.join('') || `<tr><td colspan="4">-</td></tr>`;
  }

  function renderRegMetrics(yTrue, yPred){
    const _mse = mse(yTrue,yPred); const rmse=Math.sqrt(_mse);
    let mae=0; for(let i=0;i<yTrue.length;i++) mae += Math.abs(yPred[i]-yTrue[i]); mae/=Math.max(1,yTrue.length);
    const meanY = yTrue.reduce((a,b)=>a+b,0)/Math.max(1,yTrue.length);
    let ssTot=0,ssRes=0; for(let i=0;i<yTrue.length;i++){ ssRes+=(yTrue[i]-yPred[i])**2; ssTot+=(yTrue[i]-meanY)**2; }
    const r2 = 1 - (ssRes/Math.max(ssTot,1e-12));
    document.getElementById('ml-metrics').innerHTML = `
      <tr><td>RMSE</td><td>${rmse.toFixed(6)}</td></tr>
      <tr><td>MAE</td><td>${mae.toFixed(6)}</td></tr>
      <tr><td>MSE</td><td>${_mse.toFixed(6)}</td></tr>
      <tr><td>R²</td><td>${r2.toFixed(6)}</td></tr>`;
    document.getElementById('ml-cm').innerHTML = `<div class="sub" style="grid-column:1/-1">회귀문제는 혼동행렬이 적용되지 않습니다.</div>`;
  }

  function renderPreviewRegression(yTrue, yPred, features){
    const topNames = features.slice(0,3).join(', ');
    const rows = [];
    for (let i=0;i<yTrue.length;i++){
      rows.push(`<tr>
        <td>${(yTrue[i]??'').toString()}</td>
        <td>${(yPred[i]??0).toFixed(6)}</td>
        <td>—</td>
        <td>${escapeHtml(topNames)}</td>
      </tr>`);
    }
    document.getElementById('ml-preview').innerHTML = rows.join('') || `<tr><td colspan="4">-</td></tr>`;
  }

  function renderCV(cv, isCls){
    if (isCls){
      cvHead.innerHTML = `<tr><th>지표</th><th>평균</th><th>표준편차</th></tr>`;
      cvBody.innerHTML = `
        <tr><td>Accuracy</td><td>${cv.acc.m.toFixed(4)}</td><td>${cv.acc.s.toFixed(4)}</td></tr>
        <tr><td>F1</td><td>${cv.f1.m.toFixed(4)}</td><td>${cv.f1.s.toFixed(4)}</td></tr>
        <tr><td>AUC</td><td>${cv.auc.m.toFixed(4)}</td><td>${cv.auc.s.toFixed(4)}</td></tr>`;
    }else{
      cvHead.innerHTML = `<tr><th>지표</th><th>평균</th><th>표준편차</th></tr>`;
      cvBody.innerHTML = `
        <tr><td>RMSE</td><td>${cv.rmse.m.toFixed(6)}</td><td>${cv.rmse.s.toFixed(6)}</td></tr>
        <tr><td>R²</td><td>${cv.r2.m.toFixed(6)}</td><td>${cv.r2.s.toFixed(6)}</td></tr>`;
    }
  }

  log('대기');
})();
</script>

</body>
</html>
