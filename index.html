<!-- ✅ SNOWSOFT | 간편 머신러닝 분석 (Iteration · 내부 스크롤 · details 클릭 패치 · ROC/AUC 포함 통합본) -->
<style>
  @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@500;700;900&display=swap');

  html, body { margin:0; overflow-x:hidden; }
  .ml, .ml *{font-family:'Noto Sans KR','Apple SD Gothic Neo','Malgun Gothic',system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; box-sizing:border-box}
  .ml{
    --navy:#0f2e59; --cobalt:#174a8c; --text:#0F172A; --dim:#475569; --card:#fff; --br:#e6ecf4; --r-xl:20px;
    overflow-x:clip;
  }

  .ml .card{background:var(--card);border:1px solid var(--br);border-radius:var(--r-xl);max-width:1160px;margin:24px auto 22px;padding:20px 22px;color:var(--text);
    box-shadow:0 10px 32px rgba(16,24,40,.08)}
  .ml .h2{margin:0 0 14px;font-size:20px;font-weight:800;color:var(--navy)}
  .ml .sub{color:var(--dim);font-size:14px}
  .ml label{display:block;font-size:13px;color:#2b3345;margin-bottom:6px}
  .ml select,.ml input[type=number],.ml input[type=range]{width:100%;padding:10px 12px;border:1px solid #e5e7eb;border-radius:10px;background:#fff;font-size:14px}
  .ml .chips{display:flex;flex-wrap:wrap;gap:8px}
  .ml .chip{padding:6px 10px;border-radius:999px;border:1px solid #e5e7eb;font-size:12px;cursor:pointer}
  .ml .chip.active{background:#eef2ff;border-color:#c7d2fe}
  .ml .btn{appearance:none;border:1px solid #e5e7eb;background:#fff;border-radius:12px;padding:10px 14px;font-weight:800;font-size:14px;cursor:pointer;transition:.18s; text-decoration:none}
  .ml .btn:hover{transform:translateY(-1px);box-shadow:0 6px 16px rgba(0,0,0,.08)}
  .ml .btn.primary{color:#fff;background:linear-gradient(90deg,#0f2e59,#174a8c);border:none}
  .ml .btn.ghost{background:#fff;border-color:#e2e8f0}
  .ml .btn.ghost:hover{box-shadow:0 6px 16px rgba(2,6,23,.06)}

  .ml .uploader{
    position:relative;border:1px dashed #cbd5e1;border-radius:14px;background:#fafcff;padding:14px 16px;
    display:flex;align-items:center;justify-content:space-between;gap:12px
  }
  .ml .uploader-left{display:flex;align-items:center;gap:10px}
  .ml .uploader-icon{
    width:22px;height:22px;border-radius:8px;display:inline-flex;align-items:center;justify-content:center;
    background:#eef6ff;border:1px solid #dbeafe
  }
  .ml .uploader strong{font-weight:800}
  .ml .uploader small{color:#64748b}

  .ml .panel{border:1px solid var(--br);border-radius:14px;padding:14px;min-width:0}

  /* 결과 레이아웃 */
  .ml .results{margin-top:18px}
  .ml .results-grid{
    display:grid;
    grid-template-columns:1.2fr 1fr 1fr;
    gap:16px;
    align-items:start;
  }
  @media (max-width:1100px){ .ml .results-grid{grid-template-columns:1fr 1fr} }
  @media (max-width:760px){ .ml .results-grid{grid-template-columns:1fr} }

  /* 표: 내부 세로 스크롤 허용 */
  .ml .table-wrap{
    border:1px solid #e9eef5; border-radius:14px;
    overflow-y:auto; overflow-x:auto;
    max-height:420px;
    display:block;
    -webkit-overflow-scrolling:touch;
  }
  .ml table{width:100%; border-collapse:separate; border-spacing:0; font-size:14px; min-width:560px}
  .ml thead th{background:#f8fafc;color:#2b3345;font-weight:800;text-align:left;padding:10px;border-bottom:1px solid #e9eef5; position:static}
  .ml tbody td{padding:10px;border-top:1px solid #eef2f7; word-break:break-word}

  /* Confusion Matrix */
  .ml .cm{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
  .ml .cm > div{border:1px solid #e5e7eb;border-radius:12px;padding:12px;text-align:center}
  .ml .cm .sub{font-size:11px;color:#64748b}

  .ml .log{margin-top:10px;border:1px dashed #cbd5e1;border-radius:12px;background:#fbfdff;padding:10px;font-size:12px;color:#0b1220;white-space:pre-wrap}

  .ml .report{border:1px solid var(--br);border-radius:14px;background:#f9fbff}

  /* details 클릭 겹침 방지 패치 */
  .ml details{border-top:1px solid #e6edf7; position:relative; overflow:hidden;}
  .ml details:first-of-type{border-top:none}
  .ml summary{
    list-style:none; cursor:pointer; padding:14px 16px; font-weight:800; color:#0f2e59;
    display:block; position:relative; z-index:2;
  }
  .ml summary::-webkit-details-marker{display:none}
  .ml details[open]>summary{border-bottom:1px solid #e6edf7}
  .ml .caret{font-weight:900; opacity:.5}
  .ml .report .content{padding:12px 16px 16px; color:#0f172a; line-height:1.75; font-size:14px; position:relative; z-index:1}

  .ml .jump{display:flex; gap:8px; flex-wrap:wrap; margin:6px 0 0}
</style>

<section class="ml" id="ml-app">
  <!-- 입력 카드 -->
  <div class="card">
    <div class="h2">분석 시작</div>
    <p class="sub">CSV를 선택하면 아래 설정이 활성화됩니다. (데이터는 브라우저에서만 처리)</p>

    <div class="uploader" id="ml-drop">
      <div class="uploader-left">
        <span class="uploader-icon" aria-hidden="true">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path d="M12 16V4m0 0l-4 4m4-4l4 4" stroke="#0f2e59" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M20 16v3a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1v-3" stroke="#0f2e59" stroke-width="2" stroke-linecap="round"/>
          </svg>
        </span>
        <div>
          <strong id="ml-file-name">CSV 파일을 선택하거나 드롭하세요</strong><br>
          <small id="ml-file-hint"></small>
        </div>
      </div>
      <button type="button" class="btn ghost" id="ml-choose">파일 선택</button>
      <input id="ml-file" type="file" accept=".csv,text/csv" style="display:none" />
    </div>

    <div class="log" id="ml-log">상태: 대기</div>

    <div class="controls">
      <div class="panel">
        <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:12px">
          <div>
            <label>Task</label>
            <select id="ml-task">
              <option value="auto">Auto</option>
              <option value="bincls">Binary Classification</option>
              <option value="reg">Regression</option>
            </select>
          </div>
          <div><label>Iterations</label><input id="ml-epochs" type="number" value="30" min="1"></div>
          <div><label>Batch Size</label><input id="ml-batch" type="number" value="32" min="1"></div>
        </div>

        <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px">
          <div>
            <label>Train/Test Split</label>
            <input id="ml-split" type="range" min="50" max="90" value="80">
            <div style="display:flex;justify-content:space-between;font-size:12px;color:#64748b">
              <span>Train</span><span id="ml-split-label">80%</span><span>Test</span>
            </div>
          </div>
          <div><label>Target</label><select id="ml-target"></select></div>
        </div>

        <div style="margin-top:12px">
          <label>Features (if empty = all except target)</label>
          <div id="ml-preds" class="chips"></div>
        </div>

        <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:14px">
          <button id="ml-train" class="btn primary" disabled>학습 시작</button>
          <button id="ml-clear" class="btn" disabled>초기화</button>
          <div class="jump" style="margin-left:auto">
            <a class="btn ghost" href="#ml-preview-anchor">예측 표로 이동</a>
          </div>
        </div>
        <div id="ml-progress" class="sub" style="margin-top:8px;display:none">학습 중… <span id="ml-ptext"></span></div>

        <div class="badges">
          <span class="badge">행 <b id="ml-nrow">-</b></span>
          <span class="badge">열 <b id="ml-ncol">-</b></span>
          <span class="badge">테스트 샘플 <b id="ml-ntest">-</b></span>
        </div>
      </div>
    </div>
  </div>

  <!-- 결과 카드 -->
  <div class="card results" id="ml-results-card">
    <div class="h2">결과</div>

    <!-- 임곗값 (분류일 때만) -->
    <div id="ml-thres-wrap" class="panel" style="display:none;margin-bottom:12px">
      <div style="display:flex;gap:18px;align-items:center;flex-wrap:wrap">
        <div style="min-width:220px">
          <label>Decision Threshold</label>
          <input id="ml-thres" type="range" min="1" max="99" value="50">
          <div class="sub">현재 <b id="ml-thres-label">0.50</b> (추천: <span id="ml-thres-suggest">-</span>)</div>
        </div>
        <div class="sub">임곗값을 조정하면 혼동행렬과 정밀도/재현율이 즉시 반영됩니다.</div>
      </div>
    </div>

    <div class="results-grid">
      <!-- 핵심 지표 -->
      <div class="panel">
        <div class="h2" style="font-size:16px;margin-bottom:6px">핵심 지표</div>
        <div class="table-wrap">
          <table>
            <thead><tr><th>지표</th><th>값</th></tr></thead>
            <tbody id="ml-metrics"><tr><td>—</td><td>CSV 업로드 후 실행</td></tr></tbody>
          </table>
        </div>
      </div>

      <!-- Confusion Matrix -->
      <div class="panel">
        <div class="h2" style="font-size:16px;margin-bottom:6px">Confusion Matrix</div>
        <div id="ml-cm" class="cm"></div>
      </div>

      <!-- 설명변수 중요도 -->
      <div class="panel">
        <div class="h2" style="font-size:16px;margin-bottom:6px">설명변수 중요도</div>
        <div class="table-wrap">
          <table>
            <thead><tr><th>설명변수</th><th>Score</th></tr></thead>
            <tbody id="ml-vip"></tbody>
          </table>
        </div>
      </div>

      <!-- 예측 미리보기 -->
      <div class="panel" style="grid-column: 1 / -1">
        <a id="ml-preview-anchor"></a>
        <div class="h2" style="font-size:16px;margin-bottom:6px">예측 미리보기</div>
        <div class="table-wrap">
          <table>
            <thead>
              <tr>
                <th style="min-width:120px">실제값</th>
                <th style="min-width:120px">예측값</th>
                <th style="min-width:140px">예측확률/예측치</th>
                <th>설명변수 (상위 몇 개)</th>
              </tr>
            </thead>
            <tbody id="ml-preview"></tbody>
          </table>
        </div>
        <div class="jump" style="justify-content:flex-end; margin-top:10px">
          <a class="btn ghost" href="#ml-app">상단으로</a>
        </div>
      </div>
    </div>

    <!-- 보고용 접기 -->
    <div class="report panel" style="margin-top:14px">
      <details open>
        <summary>처리/모형 요약 <span class="caret">▾</span></summary>
        <div class="content" id="ml-summary">CSV 업로드 후 요약이 표시됩니다.</div>
      </details>
      <details>
        <summary>결측치 처리 <span class="caret">▾</span></summary>
        <div class="content" id="ml-missing">
          숫자형: 중앙값 대치 · 범주형: 최빈값 대치(간단 규칙) — 상세 내역은 업로드 후 표기됩니다.
        </div>
      </details>
      <details>
        <summary>ROC / AUC 요약 <span class="caret">▾</span></summary>
        <div class="content" id="ml-roc">
          분류 수행 시 AUC와 추천 임곗값(Youden J)이 표시됩니다.
        </div>
      </details>
      <details>
        <summary>설명변수 중요도 산출 방식 <span class="caret">▾</span></summary>
        <div class="content">
          분류(Logistic): 표준화 후 가중치 절대값 |w_j| 기준 정렬 ·
          회귀(Linear): 표준화 후 회귀계수 절대값 |β_j| 기준 정렬.
          (표준화는 변수 단위 차이를 제거하여 중요도 비교를 가능하게 합니다.)
        </div>
      </details>
    </div>
  </div>
</section>

<script>
(() => {
  const $ = (sel) => document.querySelector(sel);
  const log = (msg) => { const el = $('#ml-log'); el.textContent = '상태: ' + msg; };

  /* ---------- CSV ---------- */
  function parseCSV(text) {
    const lines = text.replace(/\r/g,'').split('\n').filter(l => l.trim().length);
    const split = (line) => {
      const res = []; let cur = '', inQ = false;
      for (let i=0;i<line.length;i++){
        const c=line[i];
        if (c === '"'){ if (inQ && line[i+1] === '"'){ cur+='"'; i++; } else inQ=!inQ; }
        else if (c === ',' && !inQ){ res.push(cur); cur=''; }
        else cur += c;
      }
      res.push(cur); return res;
    };
    const headers = split(lines[0]).map(h => h.trim());
    theRows = [];
    for (let i=1;i<lines.length;i++){
      const row = split(lines[i]); const obj = {};
      headers.forEach((h,idx)=> obj[h] = row[idx] ?? '');
      theRows.push(obj);
    }
    return { headers, rows: theRows };
  }
  const isNumericArray = (arr)=> {
    let num=0, ne=0; for (const v of arr){ if (v===''||v==null) continue; ne++; if (!isNaN(parseFloat(v))) num++; }
    return num/Math.max(ne,1) > 0.9;
  };
  const toNumberOrNa = (v)=> (v===''||v==null)? NaN : (isNaN(+v)? NaN : +v);
  const median = (a)=>{ const b=a.filter(x=>!isNaN(x)).sort((x,y)=>x-y); if(!b.length) return NaN; const m=Math.floor(b.length/2); return b.length%2? b[m] : (b[m-1]+b[m])/2; };
  const mode = (arr)=>{ const m=new Map(); for(const v of arr){ const k=(v===''||v==null)?'__NA__':String(v); m.set(k,(m.get(k)||0)+1); } let best='__NA__',c=-1; m.forEach((n,k)=>{if(n>c){c=n;best=k;}}); return best==='__NA__'? '' : best; };

  /* ---------- split/scale ---------- */
  function trainTestSplit(X, y, testRatio=0.2, seed=42){
    const n=X.length, idx=Array.from({length:n},(_,i)=>i); let s=seed;
    idx.sort(()=>{ s=(s*9301+49297)%233280; return (s/233280)-0.5; });
    const nTest=Math.max(1,Math.round(n*testRatio)), test=new Set(idx.slice(0,nTest));
    const Xtr=[],ytr=[],Xte=[],yte=[]; idx.forEach(i=> test.has(i)? (Xte.push(X[i]),yte.push(y[i])) : (Xtr.push(X[i]),ytr.push(y[i])));
    return { Xtr,ytr,Xte,yte };
  }
  function standardizeFit(X){
    const p=X[0].length, mu=Array(p).fill(0), sd=Array(p).fill(0);
    for(let j=0;j<p;j++){
      let s=0,c=0; for(let i=0;i<X.length;i++){ const v=X[i][j]; if(!isNaN(v)){ s+=v; c++; } }
      mu[j]=c? s/c : 0; let v=0,cc=0; for(let i=0;i<X.length;i++){ const x=X[i][j]; if(!isNaN(x)){ v+=(x-mu[j])**2; cc++; } }
      sd[j]=cc? Math.sqrt(v/cc)||1 : 1;
    }
    const transform=(Z)=> Z.map(r=> r.map((v,j)=> isNaN(v)?0:(v-mu[j])/sd[j]));
    return { mu,sd,transform };
  }

  /* ---------- models (GD 기반; iteration 용어 사용) ---------- */
  const dot=(a,b)=>{let s=0; for(let i=0;i<a.length;i++) s+=(a[i]||0)*(b[i]||0); return s; };
  const sigmoid=(z)=> 1/(1+Math.exp(-z));

  function fitLinear(X,y,iterations=200,lr=0.05,l2=1e-4,cb){
    const n=X.length,p=X[0].length; const w=Array(p).fill(0); let b=0;
    for(let it=1;it<=iterations;it++){
      let db=0; const dw=Array(p).fill(0);
      for(let i=0;i<n;i++){ const yhat=dot(w,X[i])+b; const e=yhat-y[i]; db+=e; for(let j=0;j<p;j++) dw[j]+=e*X[i][j]; }
      for(let j=0;j<p;j++) w[j]-=lr*((dw[j]/n)+l2*w[j]); b-=lr*(db/n);
      if(cb && it%10===0) cb(it);
    }
    const predict=(Z)=> Z.map(r=> dot(w,r)+b);
    return { w,b,predict, iterations };
  }

  function fitLogistic(X,y,iterations=400,lr=0.05,l2=1e-4,cb){
    const n=X.length,p=X[0].length; const w=Array(p).fill(0); let b=0;
    for(let it=1;it<=iterations;it++){
      let db=0; const dw=Array(p).fill(0);
      for(let i=0;i<n;i++){ const z=dot(w,X[i])+b; const p1=sigmoid(z); const e=p1-y[i]; db+=e; for(let j=0;j<p;j++) dw[j]+=e*X[i][j]; }
      for(let j=0;j<p;j++) w[j]-=lr*((dw[j]/n)+l2*w[j]); b-=lr*(db/n);
      if(cb && it%20===0) cb(it);
    }
    const predictProba=(Z)=> Z.map(r=> sigmoid(dot(w,r)+b));
    const predict=(Z,thr=0.5)=> predictProba(Z).map(p=> p>=thr?1:0);
    return { w,b,predictProba,predict, iterations };
  }

  const mse=(y,yhat)=>{let s=0; for(let i=0;i<y.length;i++){ const e=yhat[i]-y[i]; s+=e*e; } return s/Math.max(1,y.length); };
  function binMetrics(yTrue,yProb,thr=0.5){
    const yPred=yProb.map(p=> p>=thr?1:0);
    let tp=0,tn=0,fp=0,fn=0;
    for(let i=0;i<yTrue.length;i++){
      const yt=yTrue[i], yp=yPred[i];
      if(yt===1 && yp===1) tp++;
      else if(yt===0 && yp===0) tn++;
      else if(yt===0 && yp===1) fp++;
      else if(yt===1 && yp===0) fn++;
    }
    const acc=(tp+tn)/Math.max(1,yTrue.length);
    const prec=tp/Math.max(1,tp+fp);
    const rec=tp/Math.max(1,tp+fn);
    const f1=(prec+rec)? (2*prec*rec/(prec+rec)) : 0;
    return { tp,tn,fp,fn,acc,prec,rec,f1,yPred };
  }

  /* ---------- ROC/AUC & 추천 임곗값 ---------- */
  function computeROC(yTrue, yProb) {
    const uniq = Array.from(new Set(yProb.concat([0, 1]))).sort((a,b)=>b-a);
    const pts = [];
    let bestJ = -Infinity, bestThr = 0.5;

    for (const thr of uniq) {
      const {tp, tn, fp, fn} = binMetrics(yTrue, yProb, thr);
      const tpr = tp / Math.max(1, tp + fn);
      const fpr = fp / Math.max(1, fp + tn);
      const J = tpr - fpr;
      if (J > bestJ) { bestJ = J; bestThr = thr; }
      pts.push({fpr, tpr});
    }

    const sorted = pts.slice().sort((a,b)=> a.fpr - b.fpr);
    let auc = 0;
    for (let i=1;i<sorted.length;i++){
      const x1 = sorted[i-1].fpr, y1 = sorted[i-1].tpr;
      const x2 = sorted[i].fpr,   y2 = sorted[i].tpr;
      auc += (x2 - x1) * (y1 + y2) / 2;
    }
    return { auc, bestThr: Math.min(0.99, Math.max(0.01, bestThr)), points: sorted };
  }

  /* ---------- state ---------- */
  let RAW=null;
  let META={ headers:[], numericCols:[], catCols:[], impute:{}, chosenTarget:null, chosenFeatures:[], task:'auto',
    mapTarget:null, invMapTarget:null, scaler:null, model:null, isClassification:false, splitRatio:0.8 };

  /* ---------- DOM ---------- */
  const fInput = $('#ml-file');
  const chooseBtn = $('#ml-choose');
  const targetSel = $('#ml-target');
  const predsWrap = $('#ml-preds');
  const splitRange = $('#ml-split');
  const splitLabel = $('#ml-split-label');
  const trainBtn = $('#ml-train');
  const clearBtn = $('#ml-clear');

  const nrowBadge = $('#ml-nrow');
  const ncolBadge = $('#ml-ncol');
  const ntestBadge = $('#ml-ntest');

  const thresWrap = $('#ml-thres-wrap');
  const thresInput = $('#ml-thres');
  const thresLabel = $('#ml-thres-label');
  const thresSuggest = $('#ml-thres-suggest');

  const metricsBody = $('#ml-metrics');
  const cmDiv = $('#ml-cm');
  const vipBody = $('#ml-vip');
  const previewBody = $('#ml-preview');

  const pWrap = $('#ml-progress');
  const pText = $('#ml-ptext');
  const summaryBox = $('#ml-summary');
  const missingBox = $('#ml-missing');

  /* ---------- uploader ---------- */
  chooseBtn.addEventListener('click', ()=> fInput.click());
  $('#ml-drop').addEventListener('dragover', (e)=> e.preventDefault());
  $('#ml-drop').addEventListener('drop', (e)=>{
    e.preventDefault();
    if (e.dataTransfer.files && e.dataTransfer.files[0]){ fInput.files=e.dataTransfer.files; handleFile(); }
  });
  fInput.addEventListener('change', handleFile);

  function handleFile(){
    const file = fInput.files && fInput.files[0]; if(!file) return;
    $('#ml-file-name').textContent = file.name;
    $('#ml-file-hint').textContent = `${(file.size/1024).toFixed(1)} KB`;
    const reader = new FileReader();
    reader.onload = ()=>{
      try{
        log('CSV 파싱 중…');
        const { headers, rows } = parseCSV(reader.result);
        RAW = { headers, rows }; resetUIAfterLoad(headers, rows); log('CSV 로드 완료');
      }catch(err){ console.error(err); log('CSV 파싱 오류'); }
    };
    reader.readAsText(file, 'utf-8');
  }

  function resetUIAfterLoad(headers, rows){
    const colData={}; headers.forEach(h=> colData[h]=rows.map(r=>r[h]));
    const numericCols=[], catCols=[];
    headers.forEach(h=> (isNumericArray(colData[h])? numericCols:catCols).push(h));

    META.headers=headers; META.numericCols=numericCols; META.catCols=catCols; META.impute={};
    for(const h of numericCols){ META.impute[h]={type:'num', value: median(colData[h].map(toNumberOrNa))}; }
    for(const h of catCols){ META.impute[h]={type:'cat', value: mode(colData[h])}; }

    targetSel.innerHTML = headers.map(h=>`<option value="${h}">${h}</option>`).join('');
    targetSel.value = headers[headers.length-1];
    META.chosenTarget = targetSel.value;

    renderFeatureChips();

    nrowBadge.textContent = rows.length;
    ncolBadge.textContent = headers.length;
    updateSplitLabel();

    trainBtn.disabled = false; clearBtn.disabled = false;

    metricsBody.innerHTML = `<tr><td>—</td><td>CSV 업로드 후 실행</td></tr>`;
    cmDiv.innerHTML = ''; vipBody.innerHTML = ''; previewBody.innerHTML = '';
    thresWrap.style.display = 'none'; pWrap.style.display = 'none';

    summaryBox.textContent = `행 ${rows.length} · 열 ${headers.length} · 숫자형 ${numericCols.length} · 범주형 ${catCols.length}`;
    missingBox.textContent = `숫자형: 중앙값(${numericCols.join(', ')}) · 범주형: 최빈값(${catCols.join(', ')})로 간단 대치합니다.`;
  }

  function renderFeatureChips(){
    const feats = META.headers.filter(h => h!==META.chosenTarget);
    META.chosenFeatures = feats.slice();
    predsWrap.innerHTML = feats.map(h=>`<span class="chip active" data-k="${h}">${h}</span>`).join('');
    predsWrap.querySelectorAll('.chip').forEach(chip=>{
      chip.addEventListener('click', ()=>{
        const k=chip.dataset.k; const on=chip.classList.toggle('active');
        if(on){ if(!META.chosenFeatures.includes(k)) META.chosenFeatures.push(k); }
        else META.chosenFeatures = META.chosenFeatures.filter(x=>x!==k);
      });
    });
  }
  targetSel.addEventListener('change', ()=>{ META.chosenTarget=targetSel.value; renderFeatureChips(); });
  function updateSplitLabel(){ const v=Number(splitRange.value); splitLabel.textContent=`${v}%`; META.splitRatio=v/100; }
  splitRange.addEventListener('input', updateSplitLabel);

  $('#ml-thres').addEventListener('input', ()=>{
    const thr = Number(thresInput.value)/100; thresLabel.textContent = thr.toFixed(2);
    if (META.isClassification && META._lastProb) applyClassificationOutputs(META._lastYtrue, META._lastProb, thr);
  });

  $('#ml-clear').addEventListener('click', ()=>{
    RAW=null; META={ headers:[], numericCols:[], catCols:[], impute:{}, chosenTarget:null, chosenFeatures:[], task:'auto',
      mapTarget:null, invMapTarget:null, scaler:null, model:null, isClassification:false, splitRatio:0.8 };
    $('#ml-file').value=''; $('#ml-file-name').textContent='CSV 파일을 선택하거나 드롭하세요'; $('#ml-file-hint').textContent='';
    targetSel.innerHTML=''; predsWrap.innerHTML='';
    metricsBody.innerHTML=`<tr><td>—</td><td>CSV 업로드 후 실행</td></tr>`; cmDiv.innerHTML=''; vipBody.innerHTML=''; previewBody.innerHTML='';
    nrowBadge.textContent='-'; ncolBadge.textContent='-'; ntestBadge.textContent='-'; thresWrap.style.display='none'; pWrap.style.display='none';
    log('대기');
  });

  $('#ml-task').addEventListener('change', ()=> META.task = $('#ml-task').value);

  /* ---------- train ---------- */
  $('#ml-train').addEventListener('click', ()=>{
    try{
      if(!RAW) return;
      const rows=RAW.rows.slice();
      const target=META.chosenTarget;
      const features=(META.chosenFeatures && META.chosenFeatures.length)? META.chosenFeatures : RAW.headers.filter(h=>h!==target);

      log('전처리 중…'); pWrap.style.display='block'; pText.textContent='전처리';
      const Xraw = rows.map(r => features.map(h => toNumberOrNa(r[h])));
      const medEach = []; for(let j=0;j<features.length;j++){ medEach[j] = median(Xraw.map(r=>r[j])); }
      const X = Xraw.map(r => r.map((v,j)=> isNaN(v)? medEach[j] : v));

      const ycol = rows.map(r => r[target]);
      let y=[], isClassification=false;

      if (META.task==='reg'){ isClassification=false; y=ycol.map(v=>toNumberOrNa(v)); }
      else if (META.task==='bincls'){ isClassification=true; }
      else { const uniq=Array.from(new Set(ycol.map(v=>String(v)))); isClassification = uniq.length <= Math.max(2, Math.sqrt(rows.length)/2); }

      if (isClassification){
        const uniq = Array.from(new Set(ycol.map(v=> String(v)))).filter(x=>x!=='');
        if (uniq.length<2){ alert('분류 수행 불가: 타깃 값이 한 종류입니다.'); pWrap.style.display='none'; return; }
        const cls = uniq.slice(0,2); const map={}, inv={}; map[cls[0]]=0; map[cls[1]]=1; inv[0]=cls[0]; inv[1]=cls[1];
        y = ycol.map(v => map[String(v)] ?? 0); META.mapTarget=map; META.invMapTarget=inv;
      }else{
        y = ycol.map(v=>toNumberOrNa(v));
        const keep=[]; for(let i=0;i<y.length;i++) if(!isNaN(y[i])) keep.push(i);
        const Xk=keep.map(i=>X[i]), yk=keep.map(i=>y[i]); X.length=0; y.length=0; X.push(...Xk); y.push(...yk);
        META.mapTarget=null; META.invMapTarget=null;
      }

      const scaler = standardizeFit(X); const Xs = scaler.transform(X);
      const { Xtr,ytr,Xte,yte } = trainTestSplit(Xs, y, 1-META.splitRatio);
      ntestBadge.textContent = yte.length;

      META.isClassification = isClassification;
      const iterations = Math.max(20, Math.min(2000, parseInt($('#ml-epochs').value||0,10)||30));

      if (isClassification){
        log('분류 학습 중…');
        const model = fitLogistic(Xtr, ytr, iterations, 0.08, 1e-4, (it)=> pText.textContent=`분류 반복 ${it}/${iterations}`);
        const prob = model.predictProba(Xte);
        META._lastProb=prob; META._lastYtrue=yte; META.model=model; META.scaler=scaler;
        thresWrap.style.display='';
        applyClassificationOutputs(yte, prob, 0.5, {features, inv:META.invMapTarget});
        renderVIP(features, model.w);
        // 추천 임곗값을 슬라이더/라벨에 즉시 반영
        {
          const rc = computeROC(yte, prob);
          const v = Math.round(Math.max(1, Math.min(99, rc.bestThr*100)));
          thresInput.value = String(v);
          thresLabel.textContent = (v/100).toFixed(2);
          const sug = document.getElementById('ml-thres-suggest'); if (sug) sug.textContent = (v/100).toFixed(2);
        }
        summaryBox.textContent = `모형: Logistic (iterations=${iterations}) · 설명변수 ${features.length}개 · 테스트 샘플 ${yte.length}개`;
      }else{
        log('회귀 학습 중…');
        const model = fitLinear(Xtr, ytr, iterations, 0.05, 1e-4, (it)=> pText.textContent=`회귀 반복 ${it}/${iterations}`);
        const pred = model.predict(Xte);
        META.model=model; META.scaler=scaler;
        thresWrap.style.display='none';
        renderRegMetrics(yte, pred);
        renderPreviewRegression(yte, pred, features);
        renderVIP(features, model.w);
        summaryBox.textContent = `모형: Linear Regression (iterations=${iterations}) · 설명변수 ${features.length}개 · 테스트 샘플 ${yte.length}개`;
      }

      log('완료'); pWrap.style.display='none';
      document.querySelector('#ml-preview-anchor')?.scrollIntoView({behavior:'smooth', block:'start'});
    }catch(err){
      console.error(err); log('오류: ' + (err?.message || err)); pWrap.style.display='none';
    }
  });

  /* ---------- render helpers ---------- */
  function applyClassificationOutputs(yTrue, yProb, thr=0.5, extra){
    const { tp,tn,fp,fn,acc,prec,rec,f1,yPred } = binMetrics(yTrue,yProb,thr);

    // ROC/AUC + 추천 임곗값(Youden J)
    const { auc, bestThr } = computeROC(yTrue, yProb);
    const tSug = (typeof bestThr === 'number' && isFinite(bestThr)) ? bestThr : 0.5;
    const tLabel = (Math.round(tSug*100)/100).toFixed(2);
    const $sug = document.getElementById('ml-thres-suggest');
    if ($sug) $sug.textContent = tLabel;

    // 지표 테이블(AUC 포함)
    document.getElementById('ml-metrics').innerHTML = `
      <tr><td>Accuracy</td><td>${acc.toFixed(4)}</td></tr>
      <tr><td>Precision</td><td>${prec.toFixed(4)}</td></tr>
      <tr><td>Recall</td><td>${rec.toFixed(4)}</td></tr>
      <tr><td>F1</td><td>${f1.toFixed(4)}</td></tr>
      <tr><td>AUC</td><td>${auc.toFixed(4)}</td></tr>
      <tr><td>Threshold</td><td>${thr.toFixed(2)}</td></tr>`;

    // 혼동행렬
    document.getElementById('ml-cm').innerHTML = `
      <div><div class="sub">TN</div><div style="font-weight:800;font-size:18px">${tn}</div></div>
      <div><div class="sub">FP</div><div style="font-weight:800;font-size:18px">${fp}</div></div>
      <div><div class="sub">FN</div><div style="font-weight:800;font-size:18px">${fn}</div></div>
      <div><div class="sub">TP</div><div style="font-weight:800;font-size:18px">${tp}</div></div>`;

    // 예측 표
    renderPreviewClassification(yTrue,yPred,yProb, extra?.features||[], extra?.inv||{});

    // ROC 요약 텍스트
    const rocBox = document.getElementById('ml-roc');
    if (rocBox){
      rocBox.innerHTML = `
        <div>· AUC = <b>${auc.toFixed(4)}</b></div>
        <div>· 추천 임곗값(Youden J 최댓값) = <b>${tLabel}</b></div>
        <div class="sub" style="margin-top:6px">슬라이더를 ${tLabel}로 맞추면 정밀도-재현율 균형(Youden J)이 최대가 됩니다.</div>
      `;
    }
  }

  function renderVIP(features, weights){
    const items = features.map((f,i)=>({ f, s: Math.abs(weights[i]||0) }))
                         .sort((a,b)=> b.s-a.s).slice(0, Math.min(20, features.length));
    $('#ml-vip').innerHTML = items.map(it=> `<tr><td>${escapeHtml(it.f)}</td><td>${it.s.toFixed(6)}</td></tr>`).join('') || `<tr><td colspan="2">-</td></tr>`;
  }

  function renderPreviewClassification(yTrue, yPred, yProb, features, inv){
    const topNames = features.slice(0,3).join(', ');
    const rows = [];
    for (let i=0;i<yTrue.length;i++){
      rows.push(`<tr>
        <td>${escapeHtml(inv?.[yTrue[i]] ?? String(yTrue[i]))}</td>
        <td>${escapeHtml(inv?.[yPred[i]] ?? String(yPred[i]))}</td>
        <td>${(yProb[i]??0).toFixed(4)}</td>
        <td>${escapeHtml(topNames)}</td>
      </tr>`);
    }
    $('#ml-preview').innerHTML = rows.join('') || `<tr><td colspan="4">-</td></tr>`;
  }

  function renderRegMetrics(yTrue, yPred){
    const _mse = mse(yTrue,yPred); const rmse=Math.sqrt(_mse);
    let mae=0; for(let i=0;i<yTrue.length;i++) mae += Math.abs(yPred[i]-yTrue[i]); mae/=Math.max(1,yTrue.length);
    const meanY = yTrue.reduce((a,b)=>a+b,0)/Math.max(1,yTrue.length);
    let ssTot=0,ssRes=0; for(let i=0;i<yTrue.length;i++){ ssRes+=(yTrue[i]-yPred[i])**2; ssTot+=(yTrue[i]-meanY)**2; }
    const r2 = 1 - (ssRes/Math.max(ssTot,1e-12));
    $('#ml-metrics').innerHTML = `
      <tr><td>RMSE</td><td>${rmse.toFixed(6)}</td></tr>
      <tr><td>MAE</td><td>${mae.toFixed(6)}</td></tr>
      <tr><td>MSE</td><td>${_mse.toFixed(6)}</td></tr>
      <tr><td>R²</td><td>${r2.toFixed(6)}</td></tr>`;
    $('#ml-cm').innerHTML = `<div class="sub" style="grid-column:1/-1">회귀문제는 혼동행렬이 적용되지 않습니다.</div>`;
  }

  function renderPreviewRegression(yTrue, yPred, features){
    const topNames = features.slice(0,3).join(', ');
    const rows = [];
    for (let i=0;i<yTrue.length;i++){
      rows.push(`<tr><td>${yTrue[i].toFixed(4)}</td><td>${yPred[i].toFixed(4)}</td><td>—</td><td>${escapeHtml(topNames)}</td></tr>`);
    }
    $('#ml-preview').innerHTML = rows.join('') || `<tr><td colspan="4">-</td></tr>`;
  }

  const escapeHtml = (s)=> String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));

  log('대기');
})();
</script>
